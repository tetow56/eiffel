#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3 (Thursday July 11th 2007) [Antoine-Auguste Parmentier]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

#ifdef __cplusplus
}
#endif
#include "hanoi.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
  }
}

void se_prinT124(FILE* file,T124*o){
fprintf(file,"NATIVE_ARRAY[INTEGER_32]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T123 M123={123,(void*)0,0,0,0};

void se_prinT123(FILE* file,T123**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"ARRAY[INTEGER_32]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT124(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}/*--*/
T48 M48={48,(void*)0,0,0,(void*)0,0,0,0,0,0};

void se_prinT48(FILE* file,T48**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_INPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"end_of_input = ");
se_prinT6(file,(&((*o)->_end_of_input)));
fprintf(file,"\n\t  ");
fprintf(file,"filtered_last_character = ");
se_prinT3(file,(&((*o)->_filtered_last_character)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"end_reached = ");
se_prinT6(file,(&((*o)->_end_reached)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_size = ");
se_prinT2(file,(&((*o)->_buffer_size)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"unread_character_flag = ");
se_prinT6(file,(&((*o)->_unread_character_flag)));
fprintf(file,"\n\t]");
}/*--*/
T47 M47={47,(void*)0,0,(void*)0,0};

void se_prinT47(FILE* file,T47**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}/*--*/
T49 M49={49,(void*)0,0};

void se_prinT49(FILE* file,T49**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"TOWER");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"t = ");
se_prinT0(file,(T0**)(&((*o)->_t)));
fprintf(file,"\n\t  ");
fprintf(file,"top = ");
se_prinT2(file,(&((*o)->_top)));
fprintf(file,"\n\t]");
}/*--*/
T40 M40={40,0,0,(void*)0,(void*)0,(void*)0};

void se_prinT40(FILE* file,T40**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_INPUT_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"last_integer = ");
se_prinT2(file,(&((*o)->_last_integer)));
fprintf(file,"\n\t  ");
fprintf(file,"valid_last_integer = ");
se_prinT6(file,(&((*o)->_valid_last_integer)));
fprintf(file,"\n\t  ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"output_filter = ");
se_prinT0(file,(T0**)(&((*o)->_output_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"input_filter = ");
se_prinT0(file,(T0**)(&((*o)->_input_filter)));
fprintf(file,"\n\t]");
}/*--*/
T25 M25={25,0,(void*)0,(void*)0,(void*)0};

void se_prinT25(FILE* file,T25**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HANOI");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"nb = ");
se_prinT2(file,(&((*o)->_nb)));
fprintf(file,"\n\t  ");
fprintf(file,"tower3 = ");
se_prinT0(file,(T0**)(&((*o)->_tower3)));
fprintf(file,"\n\t  ");
fprintf(file,"tower2 = ");
se_prinT0(file,(T0**)(&((*o)->_tower2)));
fprintf(file,"\n\t  ");
fprintf(file,"tower1 = ");
se_prinT0(file,(T0**)(&((*o)->_tower1)));
fprintf(file,"\n\t]");
}/*--*/

void se_prinT9(FILE* file,T9*o){
fprintf(file,"NATIVE_ARRAY[CHARACTER]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T7 M7={7,(void*)0,0,0};
/*Aliased storage area or unicode storage.*/
char*s25_10="\n";
char*s49_561432822="Erreur lors de l ajout";
char*s25_378628469="Situation au depart :\n";
char*s25_213395088="Situation a la fin :\n";
char*s49_1934402326="erreur lors du retrait";
char*s25_1632370714="Hauteur des tours : ";
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.c) is automatically included
  when `ace.no_check' is true (ie. all modes except -boost).
*/

int assertion_depth=1;

/*
   To print object into the trace-stack :
*/
void se_prinT0(FILE* file, T0** o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	fprintf(file,"#%p",(void*)*o);
    }
}

void se_prinT1(FILE* file, EIF_INTEGER_8* o) {
    fprintf(file,"%"PRId8,*o);
}

void se_prinT2(FILE* file, EIF_INTEGER* o) {
    fprintf(file,"%"PRId32,*o);
}

void se_prinT10(FILE* file, EIF_INTEGER_16* o) {
    fprintf(file,"%"PRId16,*o);
}

void se_prinT11(FILE* file,EIF_INTEGER_64* o) {
    fprintf(file,"%"PRId64,*o);
}

static void se_print_character(FILE* file, char c) {
    /* Produce a visible output of `c' using an Eiffelish notation.
     */
    if ((' ' <= c)&&(c <= '~')&&(c != '\'')&&(c != '\"')&&(c != '%')) {
	putc(c,file);
    }
    else {
	switch (c) {
	    case '\b': fprintf(file,"%%B"); break;
	    case '\f': fprintf(file,"%%F"); break;
	    case '\n': fprintf(file,"%%N"); break;
	    case '\r': fprintf(file,"%%R"); break;
	    case '\t': fprintf(file,"%%T"); break;
	    case '\0': fprintf(file,"%%U"); break;
	    case '\'': fprintf(file,"%%\'"); break;
	    case '\"': fprintf(file,"%%\""); break;
	    case '%':  fprintf(file,"%%%%"); break;
	    default:
		fprintf(file,"%%/%d/", (int) ((unsigned char) c));
	}
    }
}

void se_prinT3(FILE* file,EIF_CHARACTER* o) {
    putc('\'',file);
    se_print_character(file, *o);
    putc('\'',file);
}

void se_prinT4(FILE* file, EIF_REAL_32* o) {
    fprintf(file, "%.7e", ((real64_t)*o));
}

void se_prinT5(FILE* file, EIF_REAL_64* o) {
    fprintf(file, "%.16e", *o);
}

void se_prinT12(FILE* file, EIF_REAL_EXTENDED* o) {
    fprintf(file, "%.19Le", *o);
}

void se_prinT6(FILE* file, EIF_BOOLEAN* o) {
    if (*o) {
	fprintf(file,"True");
    }
    else {
	fprintf(file,"False");
    }
}

void se_prinT7(FILE* file, EIF_STRING* o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	T3* storage = (*o)->_storage;
	int count = (*o)->_count;
	int i = 0;
	putc('\"',file);
	while (i < count) {
	    se_print_character(file, storage[i++]);
	}
	putc('\"',file);
    }
}

void se_prinT8(FILE* file, EIF_POINTER* o) {
    if (*o == NULL) {
	fprintf(file,"NULL");
    }
    else {
	fprintf(file,"POINTER#%p",(void*)*o);
    }
}


/*
  The upper most context (SmartEiffel Dump stack Top) :
*/
se_dump_stack* se_dst=NULL;


int se_stack_size(se_dump_stack* ds) {
  int result = 0;
  while (ds != NULL) {
    ds = ds->caller;
    result ++;
  }
  return result;
}

void se_print_run_time_stack(void) {
  /* GENERAL.print_run_time_stack */
  handle(SE_HANDLE_ENTER_PRINT_STACK, NULL);

  se_dump_stack* origin;
  se_dump_stack* ds;
  se_dump_stack* ds2;
  int frame_count = 1;
  int rescue = 0;

  origin = se_dst;
  if (origin == NULL) {
    fprintf(SE_ERR,"Empty stack.\n");
    return ;
  }
  else {
    while (origin->exception_origin != NULL) {
      origin = origin->exception_origin;
    }

    ds = origin;
    while (ds->caller != NULL) {
      ds = ds->caller;
      frame_count++;
    }
  }
  fprintf(SE_ERR,"%d frames in current stack.\n",frame_count);
  fprintf(SE_ERR,"=====  Bottom of run-time stack  =====\n");
  while (ds != NULL) {
    se_print_one_frame(ds);
    /* Next frame : */
    if (ds == origin) {
      ds = NULL;
    }
    else if (ds->exception_origin != NULL) {
      rescue = 1;
      ds = ds->exception_origin;
    }
    else {
      ds2 = se_dst;
      while (ds2->caller != ds) {
	ds2 = ds2->caller;
      }
      ds = ds2;
    }
    if (--frame_count) {
      if (!rescue) {
        fprintf(SE_ERR,"======================================\n");
      }
      else {
        fprintf(SE_ERR,"====   Rescue stack  =================\n");
      }
    }
  }
  fprintf(SE_ERR,"=====   Top of run-time stack    =====\n");

  handle(SE_HANDLE_EXIT_PRINT_STACK, NULL);
}

int se_print_one_frame(se_dump_stack* ds) {
  return se_print_one_frame_in(SE_ERR, ds);
}

int se_print_one_frame_in(FILE* file, se_dump_stack* ds) {
  /* Return 1 for an ordinary frame (not a cecil frame or some dynamic
     dispatch extra frame). */
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;

  if (fd == NULL) {
    fprintf(file,"External CECIL call.\n");
    return 0;
  }
  fprintf(file,"%s\n",fd->name);
  if (ds->p == 0) return 0;
  local_format = fd->local_format;
  if (fd->use_current) {
    fprintf(file,"Current = ");
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    (se_prinT[id])(file, ds->current);
    fprintf(file,"\n");
  }
  while (local_count < fd->local_count) {
    while (local_format[i] != '%') {
      fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (ds->locals == NULL) {
      fprintf(file,"<unavailable>");
    }
    else {
      var = (ds->locals)[local_count];
      if (expanded) {
        (se_prinT[id])(file, (void**)(var));
      }
      else if (*var == NULL) {
        fprintf(file,"Void");
      }
      else {
        (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
      }
    }
    fprintf(file,"\n");
    local_count++;
  }
  fprintf(file,"line %d ",se_position2line(ds->p));
  fflush(file);
  fprintf(file,"column %d ",se_position2column(ds->p));
  fflush(file);
  fprintf(file,"file %s \n",p[se_position2path_id(ds->p)]);
  fflush(file);
  return 1;
}

int se_rci(se_dump_stack*caller,void*C) {
  /* Where `caller' is supposed to be reference type non Void Current
     object. This function return 1 if the class invariant must be
     checked for `C' before leaving the routine.
  */
  if (caller != NULL) {
    se_frame_descriptor* fd = caller->fd;
    if (fd == NULL) {
      /* As for example when coming via CECIL. */
      return 0;
    }
    else {
      if (fd->use_current) {
	if (fd->local_format[1] == 'R') {
	  if ((*((void**)caller->current)) == C) {
	    return 0;
	  }
	}
      }
    }
  }
  return 1;
}

void error0(char* m, char* vv) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  static char*f="*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f,m);
  if (vv!=NULL) fprintf(SE_ERR,f,vv);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,0);
#else
  handle(SE_HANDLE_RUNTIME_ERROR, m);
  se_print_run_time_stack();
  fprintf(SE_ERR,f,m);
  if (vv!=NULL)
    fprintf(SE_ERR,f,vv);
  exit(EXIT_FAILURE);
#endif
}

void error1(char*m,se_position position) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  int l = se_position2line(position);
  int c = se_position2column(position);
  int f = se_position2path_id(position);
  char* f1 = "Line : %d column %d in %s.\n";
  char* f2 = "*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,position);
#else
  handle(SE_HANDLE_RUNTIME_ERROR, m);
  se_print_run_time_stack();
  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
  exit(EXIT_FAILURE);
#endif
}

void se_print_string(FILE*stream, EIF_STRING s) {
  /* To print some Eiffel STRING. */
  if (s == NULL) {
    fprintf(stream,"Void");
  }
  else {
    int count = s->_count;
    EIF_CHARACTER* storage = s->_storage;
    int i = 0;
    fprintf(stream,"\"");
    while (count != 0) {
      fprintf(stream,"%c",storage[i]);
      i++;
      count--;
    }
    fprintf(stream,"\"");
  }
}

void se_print_bad_target(FILE*stream, int id, T0* o, int l, int c, int f) {
  /* Print Bad Target Type Error Message. */
  if (l != 0) {
    fprintf(stream,"Line : %d column %d in %s.\n",l,c,p[f]);
  }
  fprintf(stream,"*** Error at Run Time *** :\n");
  fprintf(stream,"   Target is not valid (not the good type).\n");
  fprintf(stream,"   Expected: ");
  se_print_string(stream,t[id]);
  fprintf(stream,", Actual: ");
  se_print_string(stream,t[o->id]);
  fprintf(stream,".\n");
}

void error2(T0*o, se_position position) {
  fprintf(SE_ERR,"Target Type ");
  se_print_string(SE_ERR,t[o->id]);
  fprintf(SE_ERR," is not valid.\n");
  error1("Bad target.",position);
}

T0* vc(T0* o, se_position position) {
  /*
    Void check for reference target.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Void_call_target);
#else
    error1("Call with a Void target.",position);
#endif
    return NULL;
  }
}

T0* se_string_inspect_check(T0* o, se_position position) {
  /*
    Void check for expression of type STRING in inspect.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Incorrect_inspect_value);
#else
    error1("Expression just after \"inspect\" is Void.",position);
#endif
    return NULL;
  }
}

T0* ci(int id, T0* o, se_position position) {
  /*
    Check Id for reference target.
  */
  if ( vc(o,position) != NULL) {
    if ( id == (o->id) ) {
      return o;
    }
    else {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(System_level_type_error);
#else
      int l = se_position2line(position);
      int c = se_position2column(position);
      int f = se_position2path_id(position);

      se_print_bad_target(SE_ERR,id,o,l,c,f);
      se_print_run_time_stack();
      se_print_bad_target(SE_ERR,id,o,l,c,f);
#ifdef SE_SEDB
      sedb_break(se_dst,0);
#else
      exit(EXIT_FAILURE);
#endif
#endif
    }
  }
  return o;
}

void ac_req(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Precondition);
#else
    error0("Require Assertion Violated.",vv);
#endif
  }
}

void ac_ens(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Postcondition);
#else
    error0("Ensure Assertion Violated.",vv);
#endif
  }
}

void ac_inv(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Class_invariant);
#else
    error0("Class Invariant Violation.",vv);
#endif
  }
}

void ac_liv(int v,char*vv) {
  /* Assertion Check : Loop Invariant check. */
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_invariant);
#else
    error0("Loop Invariant Violation.",vv);
#endif
  }
}

int ac_lvc(int lc,int lv1,int lv2) {
  /* Assertion Check : Loop Variant check. */
  if (lc == 0) {
    if (lv2 < 0) {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(Loop_variant);
#else
      {
	char msg [64];
	sprintf(msg,"Bad First Variant Value = %d\n",lv2);
	error0(msg,NULL);
      }
#endif
    }
    else {
      return lv2;
    }
  }
  else if ((lv2 < 0) || (lv2 >= lv1)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_variant);
#else
    {
      char msg [512];
      sprintf(msg,
	      "Bad loop variant.\nLoop body counter = %d (done)\n"
	      "Previous Variant = %d\nNew Variant = %d\n",
	      lc,lv1,lv2);
      error0(msg,NULL);
    }
#endif
  }
  return lv2;
}

void ac_civ(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Check_instruction);
#else
    error0("Check Assertion Violated.",vv);
#endif
  }
}

T0* se_evobt(T0* o, se_position position) {
    /*
      Error Void Or Bad Type.
    */
    if (!o) {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(Void_call_target);
#else
	error1("Target is Void.",position);
#endif
    }
    else {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(System_level_type_error);
#else
	error2(o,position);
#endif
    }
    return o; /* Dummy return to avoid C warnings. */
}

void se_signal_handler(int sig) {
  printf("Received signal %d.\n",sig);
#ifdef SE_SEDB
  signal(sig,se_signal_handler);
  sedb_signal_handler(sig);
#else
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

void se_gc_check_id(void*o,int id) {
  if (id != (((T0*)o)->id)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#else
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    se_print_run_time_stack();
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    exit(EXIT_FAILURE);
#endif
  }
}

se_dump_stack* se_new_dump_stack(se_dump_stack* copy) {
  se_dump_stack* result = NULL;
  se_frame_descriptor* fd;
  int i, j, o, p, n;
  int local_count;
  char* local_format;
  int id;
  void** var;
  int local_size;
  int expanded;

  void*** _i;
  void** _ref;
  char*  _exp;

  if (copy != NULL) {
    fd = copy->fd;
    result = (se_dump_stack*)se_malloc(sizeof(se_dump_stack));
    if (result != NULL) {
      result->fd               = fd;
      result->p                = copy->p;
      result->caller           = copy->caller;
      result->current          = NULL;
      result->locals           = NULL;
      result->exception_origin = NULL;

      if (fd != NULL) {
	local_format = fd->local_format;
	i = 0;
	if (fd->use_current) {
	  result->current = copy->current;
	  /* Place i after the Current definition: */
	  i = 2;
	  id = 0;
	  while (local_format[i] != '%') {
	    id = (id * 10) + (local_format[i++] - '0');
	  }
	  i++;
	}

	/*
	 *
	 * p: sum of the number of pointers ("indirections") per local
	 *    -> 1 for an expanded
	 *    -> 2 for a reference
	 *
	 * o: total malloc'ed size
	 *
	 * _i: access to the first indirection pointer
	 *
	 * _ref: access to the second indirection pointer of a reference object
	 *       _ref == (T0*)(*_i)
	 *
	 * _exp: access to a copy of the expanded object
	 *       _exp == *((char*)_i)
	 *
	 *
	 *
	 * For instance, if "0" is the first local, a reference and "4" is the
	 * second local, an expanded type (say, a 6-byte structure noted
	 * "XXXXXXXXXXX", with 64-bit padding "/"):
	 *
	 *
	 *
	 * result->locals
	 *       |                ------------
	 *       |               |            |
	 *       |    -----------|------------v--------------
	 *        -->| | | | |===+===|===+===|XXXXXXXXXXX|/|/|
	 *           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|0|1|2|3|
	 *           |===+===| | | | |===+===| | | | | | | | |
	 *            ---|------------^--|-------------------
	 *               |            |  |
	 *                ------------    --------------------------> object
	 *
	 *           |-> _i          |-> _ref         _exp <-|
	 *
	 *
	 *
	 * Note: Those "|->" denote the start value and way of
	 *       progression of the pointers
	 *
	 *
	 * result->locals is defined as a (void***) but its real "type" depends on
	 * which element is accessed (as in the live stack; but in the live stack,
	 * only the first indirection is in the struct; the remaining data is on
	 * the native stack).
	 *
	 */

	if (copy->locals != NULL) {
	  j = i;

	  local_count = local_size = p = o = 0;

	  while (local_count < fd->local_count) {
	    while (local_format[i++] != '%');
	    expanded = ((local_format[i++] == 'E')?1:0);
	    id = 0;
	    while (local_format[i] != '%') {
	      id = (id * 10) + (local_format[i++] - '0');
	    }
	    i++;
	    if (expanded) {
	      p++;
	      o = se_strucT[id];
	      o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
	      local_size += o;
	    }
	    else {
	      p+=2;
	    }
	    local_count++;
	  }

	  o = p * sizeof(void*) + local_size;
	  result->locals = (void***)se_malloc(o);
	  _i   = result->locals;
	  _exp = (char*)_i + o;
	  _ref = (void**)_i + local_count;

	  i = j;
	  local_count = 0;
	  while (local_count < fd->local_count) {
	    while (local_format[i++] != '%');
	    expanded = ((local_format[i++] == 'E')?1:0);
	    id = 0;
	    while (local_format[i] != '%') {
	      id = (id * 10) + (local_format[i++] - '0');
	    }
	    i++;
	    var = (copy->locals)[local_count];
	    if (expanded) {
	      o = n = se_strucT[id];
	      o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
	      _exp -= o;
	      *(char**)_i = _exp;
	      memset(_exp, 0, o);
	      memcpy(_exp, var, n);
	    }
	    else {
	      *_i = _ref;
	      *_ref = *var;
	      _ref++;
	    }
	    local_count++;
	    _i++;
	  }
	}
      }
    }
  }
  return result;
}

void se_delete_dump_stack(se_dump_stack* ds) {
  if (ds != NULL) {
    if (ds->locals != NULL) free(ds->locals);
    free(ds);
  }
}


void se_print_locals_in(FILE* file, se_dump_stack* ds, int enter) {
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;
  int printed = 0;
  int display;

  if (ds->p == 0) return;
  local_format = fd->local_format;
  if (fd->use_current) {
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      i++;
    }
    i++;
  }
  while (local_count < fd->local_count) {
    display = (strncmp(local_format+i, "Result%", 7)==0) != enter;
    if (display) {
      if (printed)
	fprintf(file,", ");
      else
	fprintf(file,"(");
      printed++;
    }
    
    while (local_format[i] != '%') {
      if (display) fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    if (display) fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (display) {
      if (ds->locals == NULL) {
	fprintf(file,"<unavailable>");
      }
      else {
	var = (ds->locals)[local_count];
	if (expanded) {
	  (se_prinT[id])(file, (void**)(var));
	}
	else if (*var == NULL) {
	  fprintf(file,"Void");
	}
	else {
	  (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
	}
      }
    }
    local_count++;
  }
  if (printed)
    fprintf(file,")\n");
  else
    fprintf(file,"\n");

}

#ifdef SE_TRACE
static int se_call_depth=0;

void se_print_call_trace(se_dump_stack *ds) {
  int i;
  if (ds) {
    int enter = ds->caller == se_dst;
    
    if (enter)
      se_call_depth++;

    if (se_call_depth < 0)
      se_call_depth=0;

    for(i=se_call_depth<<1; i; i--)
      putchar(' ');

    if (enter) {
      printf("enter ");
      printf("%s", ds->fd->name);
      se_print_locals_in(stdout, ds, 1);
    } else {
      if (se_dst) {
	printf("leave ");
	printf("%s", se_dst->fd->name);
	se_print_locals_in(stdout, se_dst, 0);
	se_call_depth--;
      }
    }
  } else {
    for(i=se_call_depth<<1; i; i--)
      putchar(' ');
    printf("leave ");
    printf("%s", se_dst->fd->name);
    se_print_locals_in(stdout, se_dst, 0);
    se_call_depth--;
  }
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

/*
   This file (SmartEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/
/*
   The `mark_stack_and_registers' C function is called by the Garbage
   Collector (GC) of SmartEiffel. It has to be customized for some systems,
   but also for some C compilers. This file provides some definitions in the
   end and has to be completed for systems which need specific work.

   On some architectures, addresses increase as the stack grows; or,
   conversely, addresses decrease as the stack grows. A C compiler may be
   clever enough to hide some root object inside registers. Unfortunately all
   registers are not always accessible via the C `setjmp' function!

   Thus, in order to be able to use the GC on your architecture/C-compiler,
   you have to provide the correct `mark_stack_and_registers' function.

   What is the `mark_stack_and_registers' function supposed to do?  The
   `mark_stack_and_registers' function is supposed to notify the GC with all
   the possible roots one can find in the C stack and registers by calling the
   `gc_mark' function. A root is an object which must not be collected.  The
   SmartEiffel GC already knows about some root objects like once function
   results or manifest strings. The `mark_stack_and_registers' function has to
   notify the other possible roots. Obviously, one can find in the C stack any
   kind of adresses, but the `gc_mark' function is clever enough to determine
   if the passed pointer is an Eiffel object or not.  When the passed pointer
   reaches some Eiffel object, this object as well as its descendant(s) are
   automatically marked as un-collectable.

   In order to provide the most appropriate `mark_stack_and_registers'
   function, the very first question is to know about the way the C stack is
   managed (addresses of the stack may increase or decrease as the C stack
   grows). The DEFAULT BEHAVIOUR FOR UNKNOWN SYSTEMS is to consider ADDRESSES
   DECREASE AS THE STACK GROWS, as it's the most common case.  The global C
   variable `stack_bottom' is set with some pointer which is supposed to be
   the bottom of the stack (this variable is automatically initialized in the
   C main function).  Note: using the current stack pointer inside
   `mark_stack_and_registers', it is quite obvious to determine if addresses
   increase or not as the C stack grows.  Note2: on some systems, the stack is
   not in contiguous addresses. In such case, `mark_stack_and_registers' has
   to go through all the stack fragments.

   Some roots may be stored only in registers and not in the C stack.  In
   order to reach the registers as well, the first attempt is to use setjmp,
   in the hope that setjmp will save registers in the stack!  Note: this
   technique do not work on processors using windows registers (such as sparc
   processors).

*/

int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom=NULL;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

/* Return the index where chunk `c' is (or is to be) in the `gcmt', 
   between `min' and `max' indexes. */
static unsigned int binary_search_in_gcmt(register unsigned int min, 
					  register unsigned int max, 
					  register mch* c){
  register unsigned int mid;
  while (min<max){
    mid=(min+max)>>1;
    if (gcmt[mid]<c)
      min=mid+1;
    else
      max=mid;
  }
  if (gcmt[min]<c)
    return min+1;
  else
    return min;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next; register rsoc *current;
  unsigned int count = rsocfl_count();
  register unsigned int where = gcmt_used;
  register unsigned int how_many;

  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (NULL != current) {
      next=current->next;
      if (current->isize == current->header.size) {
	where = binary_search_in_gcmt(0, where-1, (mch*)current);
	how_many = gcmt_used - 1 - where;
	if (how_many > 0)
	  memmove(gcmt+where, gcmt+where+1, how_many*sizeof(mch*));
	free(current); gcmt_used--; rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

int gc_memory_used(void) {
  int i;
  int result = 0;
  mch* mch;
  for (i = gcmt_used; i --> 0; ) {
    mch = gcmt[i];
    switch(mch->state_type) {
    case RSO_USED_CHUNK:
    case FSO_USED_CHUNK:
    case FSO_STORE_CHUNK:
      result += mch->size;
      break;
    default:
      break;
    }
  }
  return result;
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

/* return the mch containing p or NULL if p is not 
 * a valid address or was externally allocated 
 */
mch * gc_find_chunk(void * p){
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if((char*)p<(char*)c+c->size)   /* check for upper bound */
      if (!(FREE_CHUNK(c->state_type)))
	return c;
  }
  return NULL;
}

void gc_mark(void*p) {
  mch * c = gc_find_chunk(p);
  if(NULL != c) 
    (c->amfp)(c,p);
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */

  /* The lines commented out with --perf-- were killing performance under certain circumstances, *
   * especially with gcc -O3 <FM-15/04/2005>                                                     */

  /* --perf-- if (fsocfl == NULL) { */
  if (fsoc_count >= fsoc_count_ceil) {
    if (fsoc_count_ceil < FSOC_LIMIT) {
      fsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = fsoc_count + (fsoc_count/3);
      if (fsoc_count_ceil < c)
	fsoc_count_ceil = c;
    }
  }
  /* --perf-- }
     else {
     if (fsoc_count_ceil < fsoc_count) {
     fsoc_count_ceil = fsoc_count;
     }
     }
  */
  /* Compute rsoc_count_ceil: */
  /* --perf-- if (rsocfl == NULL) {*/
  if (rsoc_count >= rsoc_count_ceil) {
    if (rsoc_count_ceil < RSOC_LIMIT) {
      rsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = rsoc_count + (rsoc_count / 3);
      if (rsoc_count_ceil < c) {
	rsoc_count_ceil = c;
      }
    }
  }
  /* --perf -- }
     else {
     if (rsoc_count_ceil < rsoc_count) {
     rsoc_count_ceil = rsoc_count;
     }
     }
  */
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).`gcmt_used' is updated.
  */
  unsigned int where=0;
  unsigned how_many;
  if (gcmt_used>0){
    where=binary_search_in_gcmt(0, gcmt_used-1, c);
    if (gcmt_used == gcmt_max) {
      gcmt_max <<= 1;
      gcmt = ((mch**)(se_realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
    }
    how_many = gcmt_used - where;
    if (how_many > 0)    
      memmove(gcmt+where+1, gcmt+where, how_many*sizeof(mch*));
  }
  gcmt[where]=c;
  gcmt_used++;
}

static char*rso_from_store(na_env*nae,unsigned int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	/* No need to register chunks with no free_list_of_large
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	*/
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

/* *** To be removed */
#ifdef __TINYC__
static rsoc MRSOC = {
#else
static const rsoc MRSOC = {
#endif
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(unsigned int size) {
  register unsigned int best_size = 0;
  unsigned int acceptable_loss;
  register rsoc *pc, *best_pc, *best_c, *c;
  if (NULL==rsocfl)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  if (SE_GC_DEFAULT_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = (size >> 4);
  else if (SE_GC_LOW_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = 0;
  else /* SE_GC_HIGH_MEMORY_STRATEGY == se_gc_strategy */
    acceptable_loss = (size >> 2);

  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (NULL != best_pc)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  if ((best_size - size) > acceptable_loss){
    do {
      if ((c->header.size >= size) && (c->header.size < best_size)) {
	best_c = c;
	best_pc = pc;
	best_size = c->header.size;
	if ((best_size - size) <= acceptable_loss) break;
      }
      pc=c;
      c=c->next;
    }
    while(NULL!=c);
  }
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,unsigned int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,unsigned int size) {
  rsoc*c=nae->chunk_list;
  unsigned int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if (c->header.size > RSOC_SIZE) {
      if (c->header.size-csize > RSOC_MIN_STORE*4) {
	int csize_left=c->header.size-csize;
	if ((csize_left%sizeof(double))!=0) {
	  csize_left-=(csize_left%sizeof(double));
	  csize=c->header.size-csize_left;
	}
	c->header.size=csize_left;
	c->next=rsocfl;
	rsocfl=c;
	c=(rsoc*)(((char*)c)+csize_left);
	c->isize=0; /* c split from a larger chunk */
	gc_add_into_gcmt((mch*)c);      
	c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
	c->header.swfp=(void(*)(mch*))rsoc_sweep;
      }
      /* since objects bigger than RSOC_SIZE must be the only object in their chunk, we do not want to have
	 some store left after them. Therefore, we do not set csize to c->header.size in an else block
	 here. */
      c->header.size=csize;
    }
    else {
      csize=c->header.size;
    }
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    return rso_from_store(nae,size);
  }
  return NULL;
}

/* size in bytes, including header size */
char*new_na(na_env*nae,unsigned int size) {
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      unsigned int rounded_size= chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    unsigned int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);

  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

unsigned int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  register unsigned int r=0;
  register rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

unsigned int fsocfl_count(void) {
  register unsigned int r=0;
  register fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    fsoc_count++;
    gc_update_ceils();
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

#if defined(__sparc__) || defined(sparc) || defined(__sparc)
/* For SPARC architecture.
   As this part contains assembly code (asm), you must not use
   the flag -ansi of gcc compiler.
*/

void mark_loop(void) {
  void** max = stack_bottom;
  void** stack_pointer;
  void* stack_top[2]={NULL,NULL};
  stack_pointer = stack_top;
  /* Addresses decrease as the stack grows. */
  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}

void mark_stack_and_registers(void) {
#  if defined(__sparcv9)
  asm(" flushw");
#  else
  asm(" ta      0x3   ! ST_FLUSH_WINDOWS");
#  endif
  mark_loop();
}

#elif defined(__ELATE__) || defined(ELATE)
/* GNU Eiffel's VP (Virtual Processor) garbage collector for Elate.
   (c) 2000 Rudi Chiarito <rudi@amiga.com>

   Thanks to Andy Stout and Kevin Croombs at Tao Group for their
   precious help!

   ChangeLog:
   - 2000-06-12 Rudi Chiarito <rudi@amiga.com>
     * Version 1.0
   - 2001-01-01 Joseph Kiniry <kiniry@acm.org>
     * Integrated with new SE 0.75b
   - 2001-08-10 Rudi Chiarito <rudi@amiga.com>
     * Inlined and optimised range marking
     * Added some more comments
     * Added conditional breakpoint in mark_stack_and_registers
   - 2002-09-21 Rudi Chiarito <rudi@amiga.com>
     * Removed redundant 'ret'
*/

__inline__ void mark_stack_and_registers(void)
{

  void *pointer_to_gc_mark = &gc_mark;

  __asm__ __volatile__
  (
    /*
      WARNING: funky code ahead!
      \t and \n are needed to make the final output easier to read
      while debugging. Hopefully you'll never have to bother with all
      of this.

      Registers:
        p0  pointer to stack block
        p1  pointer to gc_mark()
        p2  scratch pointer
        i0  length of current stack block
        i1  scratch register
    */

#  ifdef __ELATE_SE_DEBUG_GC
   "\tqcall sys/cii/breakpt,(-:-)\n"
#  endif

   "\tsync\n"                          /* spill all the registers */
   "\tsyncreg\n"                       /* to the stack */

   "\tcpy.p %0,p1\n"                   /* pointer to gc_mark() */

   /* pointer to the current stack block */
   "\tcpy.p [gp+PROC_STACK],p0\n"

   /* point to last location in the block, before the descriptor */
   "\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

   /* mark the contents of the current stack block */
   "\twhile p2>=sp\n"
      "\t\tgos p1,(p2 : -)\n"
      "\t\tsub.p 4,p2\n"
   "\tendwhile\n"

   /* now scan other blocks (if any) */

   "\tloop\n"
      "\t\tcpy.p [p0 - STK_SIZE + STK_LINK],p0\n" /* get next block */
      "\t\tbreakif p0=NULL\n"

      /* point to last location in the block, before the descriptor */
      "\t\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

      /* mark this block */
      "\t\twhile p2>=p0\n"

         "\t\t\tgos p1,(p2 : -)\n"
         "\t\t\tsub.p 4,p2\n"
      "\t\tendwhile\n"
   "\tendloop\n"

   : /* no output */
   : "p" (pointer_to_gc_mark)
   : "p0", "p1", "p2", "i0" 
   );
}

#elif defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)

/****************************************************************************
 * Generic code for architectures where addresses increase as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers) + ((sizeof(JMP_BUF)/sizeof(void*))-1);
  /* stack_pointer will traverse the JMP_BUF as well (jmp_buf size is added, 
     otherwise stack_pointer would be below the registers structure). */

#  if !defined(SE_BOOST)
  if (stack_pointer < max) {
    fprintf(stderr, "Wrong stack direction: your stack decrease as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer >= max) {
    gc_mark(*(stack_pointer--));
  }
}
#else

/****************************************************************************
 * Generic code for architectures where addresses decrease as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers);

#  if !defined(SE_BOOST)
  if (stack_pointer > max) {
    fprintf(stderr, "Wrong stack direction: the stack addresses increase as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}
#endif

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
unsigned int fsoc_count_ceil=52;
unsigned int rsoc_count_ceil=8;

/*NATIVE_ARRAY[INTEGER_32]*/void r124set_all_with(se_dump_stack*caller,T124 C,T2 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with"" NATIVE_ARRAY[INTEGER_32]",1,3,"%E124%v%E2%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06A1FA04/*l506c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A1FD14/*l509c10/native_array.e*/);
ac_req(((int32_t)(a2))>=(/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
(ds.p=0x06A2020A/*l514c5/native_array.e*/);
_i=a2;
while (!(((ds.p=0x06A2040E/*l516c7/native_array.e*/),((int32_t)(_i))<(/*IC*/(T2)(INT8_C(0))))))
{
(ds.p=0x06A2060A/*l518c5/native_array.e*/);
(C)[_i]=(a1);
(ds.p=0x06A2070A/*l519c5/native_array.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/T6 r124is_not_null(se_dump_stack*caller,T124 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null"" NATIVE_ARRAY[INTEGER_32]",1,1,"%E124%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06A31804/*l792c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x06A31A08/*l794c4/native_array.e*/);
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/T124 r124realloc(se_dump_stack*caller,T124 C,T2 a1,T2 a2){
T124 R=(void*)0;
void**locals[3];
static se_frame_descriptor fd={"realloc"" NATIVE_ARRAY[INTEGER_32]",1,3,"%E124%old_nb_elts%E2%new_nb_elts%E2%Result%E124%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06A03304/*l51c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A03A08/*l58c4/native_array.e*/);
ac_req(r124is_not_null(&ds,C),"is_not_null");
(ds.p=0x06A03B20/*l59c16/native_array.e*/);
ac_req(((int32_t)(a1))>(/*IC*/(T2)(INT8_C(0))),"old_nb_elts > 0");
(ds.p=0x06A03C20/*l60c16/native_array.e*/);
ac_req(((int32_t)(a1))<(a2),"old_nb_elts < new_nb_elts");
fd.assertion_flag=1;
}
(ds.p=0x06A03E08/*l62c4/native_array.e*/);
R=new124(a2);
(ds.p=0x06A03F16/*l63c11/native_array.e*/);
r124copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A04116/*l65c11/native_array.e*/);
ac_ens(r124is_not_null(&ds,R),"Result.is_not_null");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/void r124copy_from(se_dump_stack*caller,T124 C,T124 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from"" NATIVE_ARRAY[INTEGER_32]",1,3,"%E124%model%E124%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06A24204/*l578c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A24514/*l581c10/native_array.e*/);
ac_req(((int32_t)(a2))>=(/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
(ds.p=0x06A24A0A/*l586c5/native_array.e*/);
_i=a2;
while (!(((ds.p=0x06A24C0E/*l588c7/native_array.e*/),((int32_t)(_i))<(/*IC*/(T2)(INT8_C(0))))))
{
(ds.p=0x06A24E0A/*l590c5/native_array.e*/);
(C)[_i]=((a1)[_i]);
(ds.p=0x06A24F0A/*l591c5/native_array.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/T6 r124all_default(se_dump_stack*caller,T124 C,T2 a1){
T6 R=0;
T2 _i=0;
T2 _v=0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[INTEGER_32]",1,4,"%E124%upper%E2%Result%E6%i%E2%v%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06A2DF04/*l735c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A2E314/*l739c10/native_array.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
(ds.p=0x06A2E80A/*l744c5/native_array.e*/);
R=((T6)(1));
(ds.p=0x06A2E90A/*l745c5/native_array.e*/);
_i=a1;
while (!(((ds.p=0x06A2EB16/*l747c11/native_array.e*/),(T6)((((int32_t)(_i))<(/*IC*/(T2)(INT8_C(0))))||((T6)(r6_px_not(&ds,(T6)(R))))))))
{
(ds.p=0x06A2ED0A/*l749c5/native_array.e*/);
_v=(C)[_i];
if(((ds.p=0x06A2EE10/*l750c8/native_array.e*/),(_v,1))){
(ds.p=0x06A2EF0C/*l751c6/native_array.e*/);
R=((T6)(r2is_default(&ds,_v)));
}
(ds.p=0x06A2F10A/*l753c5/native_array.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/void r124clear_all(se_dump_stack*caller,T124 C,T2 a1){
T2 _v=0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[INTEGER_32]",1,3,"%E124%upper%E2%v%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06A21D04/*l541c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A22014/*l544c10/native_array.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
(ds.p=0x06A2250A/*l549c5/native_array.e*/);
_i=a1;
while (!(((ds.p=0x06A2270E/*l551c7/native_array.e*/),((int32_t)(_i))<(/*IC*/(T2)(INT8_C(0))))))
{
(ds.p=0x06A2290A/*l553c5/native_array.e*/);
(C)[_i]=(_v);
(ds.p=0x06A22A0A/*l554c5/native_array.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06A22D08/*l557c4/native_array.e*/);
ac_ens(r124all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123set_all_with(se_dump_stack*caller,T123* C,T2 a1){
T2 o64_82_12=0;
void**locals[2];
static se_frame_descriptor fd={"set_all_with"" ARRAY[INTEGER_32]",1,2,"%R123%v%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0860DC04/*l220c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o64_82_12;
set_dump_stack_top(&ds);/*link*/
o64_82_12=r123count(&ds,C);
(ds.p=0x0860DE18/*l222c12/array.e*/);
r124set_all_with(&ds,(/*RF2*/(C)->_storage/*i4p*/),a1,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),(/*RF2*/(C)->_lower/*i4p*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08005208/*l82c4/collection.e*/);
ac_ens((r123count(&ds,C))==(o64_82_12),"count = old count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123remove_last(se_dump_stack*caller,T123* C){
T2 o64_258_12=0;
T2 o64_259_12=0;
void**locals[2];
static se_frame_descriptor fd={"remove_last"" ARRAY[INTEGER_32]",1,2,"%R123%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08A03B04/*l59c2/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&o64_258_12;
locals[1]=(void**)&o64_259_12;
set_dump_stack_top(&ds);/*link*/
o64_258_12=r123count(&ds,C);
o64_259_12=(/*RF2*/(C)->_upper/*i4p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0800FF08/*l255c4/collection.e*/);
ac_req(r6_px_not(&ds,(T6)(r123is_empty(&ds,C))),"not is_empty");
fd.assertion_flag=1;
}
(ds.p=0x08A03D08/*l61c4/arrayed_collection.e*/);
/*SFN*/(C->_upper/*i4p*/)=r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08010208/*l258c4/collection.e*/);
ac_ens((r123count(&ds,C))==(r2_ix_45(&ds,o64_258_12,/*IC*/(T2)(INT8_C(1)))),"count = old count - 1");
(ds.p=0x08010308/*l259c4/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*i4p*/))==(r2_ix_45(&ds,o64_259_12,/*IC*/(T2)(INT8_C(1)))),"upper = old upper - 1");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123add(se_dump_stack*caller,T123* C,T2 a1,T2 a2){
T2 o64_158_16=0;
T2 o64_159_16=0;
void**locals[4];
static se_frame_descriptor fd={"add"" ARRAY[INTEGER_32]",1,4,"%R123%element%E2%index%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08A03004/*l48c2/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&o64_158_16;
locals[3]=(void**)&o64_159_16;
set_dump_stack_top(&ds);/*link*/
o64_158_16=r123count(&ds,C);
o64_159_16=(/*RF2*/(C)->_upper/*i4p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08009A14/*l154c10/collection.e*/);
ac_req(r2in_range(&ds,a2,(/*RF2*/(C)->_lower/*i4p*/),r2_ix_43(&ds,(/*RF2*/(C)->_upper/*i4p*/),/*IC*/(T2)(INT8_C(1)))),"index.in_range(lower, upper + 1)");
fd.assertion_flag=1;
}
if(((ds.p=0x08A0320E/*l50c7/arrayed_collection.e*/),(a2)==(r2_ix_43(&ds,(/*RF2*/(C)->_upper/*i4p*/),/*IC*/(T2)(INT8_C(1)))))){
(ds.p=0x08A0330A/*l51c5/arrayed_collection.e*/);
r123add_last(&ds,C,a1);
}
else{
(ds.p=0x08A0350A/*l53c5/arrayed_collection.e*/);
r123add_last(&ds,C,a1);
(ds.p=0x08A0360A/*l54c5/arrayed_collection.e*/);
r123move(&ds,C,a2,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),/*IC*/(T2)(INT8_C(1))),/*IC*/(T2)(INT8_C(1)));
(ds.p=0x08A0370A/*l55c5/arrayed_collection.e*/);
r123put(&ds,C,a1,a2);
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08009D08/*l157c4/collection.e*/);
ac_ens((r123item(&ds,C,a2))==(a1),"item(index) = element");
(ds.p=0x08009E08/*l158c4/collection.e*/);
ac_ens((r123count(&ds,C))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o64_158_16)),"count = 1 + old count");
(ds.p=0x08009F08/*l159c4/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*i4p*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o64_159_16)),"upper = 1 + old upper");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123add_last(se_dump_stack*caller,T123* C,T2 a1){
T2 _new_capacity=0;
T2 o64_143_16=0;
T2 o64_144_12=0;
T2 o64_145_16=0;
void**locals[5];
static se_frame_descriptor fd={"add_last"" ARRAY[INTEGER_32]",1,5,"%R123%element%E2%new_capacity%E2%old value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08610904/*l265c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
locals[2]=(void**)&o64_143_16;
locals[3]=(void**)&o64_144_12;
locals[4]=(void**)&o64_145_16;
set_dump_stack_top(&ds);/*link*/
o64_143_16=r123count(&ds,C);
o64_144_12=(/*RF2*/(C)->_lower/*i4p*/);
o64_145_16=(/*RF2*/(C)->_upper/*i4p*/);
if(((ds.p=0x08610D20/*l269c16/array.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i4p*/)))<(r2_ix_43(&ds,r123count(&ds,C),/*IC*/(T2)(INT8_C(1)))))){
if(((ds.p=0x08610E10/*l270c8/array.e*/),((/*RF2*/(C)->_capacity/*i4p*/))==(INT8_C(0)))){
(ds.p=0x08610F0C/*l271c6/array.e*/);
_new_capacity=/*IC*/(T2)(INT8_C(16));
(ds.p=0x0861100C/*l272c6/array.e*/);
/*SFN*/(C->_storage/*i4p*/)=new124(_new_capacity);
(ds.p=0x0861110C/*l273c6/array.e*/);
/*SFN*/(C->_capacity/*i4p*/)=_new_capacity;
}
else{
(ds.p=0x0861130C/*l275c6/array.e*/);
_new_capacity=r2_ix_42(&ds,(/*RF2*/(C)->_capacity/*i4p*/),/*IC*/(T2)(INT8_C(2)));
(ds.p=0x0861140C/*l276c6/array.e*/);
/*SFN*/(C->_storage/*i4p*/)=r124realloc(&ds,(/*RF2*/(C)->_storage/*i4p*/),(/*RF2*/(C)->_capacity/*i4p*/),_new_capacity);
(ds.p=0x0861150C/*l277c6/array.e*/);
/*SFN*/(C->_capacity/*i4p*/)=_new_capacity;
}
}
(ds.p=0x08611808/*l280c4/array.e*/);
/*SFN*/(C->_upper/*i4p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_upper/*i4p*/),/*IC*/(T2)(INT8_C(1)));
(ds.p=0x08611908/*l281c4/array.e*/);
r123put(&ds,C,a1,(/*RF2*/(C)->_upper/*i4p*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08008E08/*l142c4/collection.e*/);
ac_ens((r123last(&ds,C))==(a1),"last = element");
(ds.p=0x08008F08/*l143c4/collection.e*/);
ac_ens((r123count(&ds,C))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o64_143_16)),"count = 1 + old count");
(ds.p=0x08009008/*l144c4/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*i4p*/))==(o64_144_12),"lower = old lower");
(ds.p=0x08009108/*l145c4/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*i4p*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o64_145_16)),"upper = 1 + old upper");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123ensure_capacity_and_bounds(se_dump_stack*caller,T123* C,T2 a1,T2 a2,T2 a3){
T2 _value=0;
void**locals[4];
static se_frame_descriptor fd={"ensure_capacity_and_bounds"" ARRAY[INTEGER_32]",1,4,"%R123%needed_capacity%E2%low%E2%up%E2%value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08603B04/*l59c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
locals[3]=(void**)&_value;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08603D0E/*l61c7/array.e*/);
ac_req(((int32_t)(a3))>=(r2_ix_45(&ds,a2,/*IC*/(T2)(INT8_C(1)))),"up >= low - 1");
(ds.p=0x08603E28/*l62c20/array.e*/);
ac_req(((int32_t)(a1))>=(r2_ix_43(&ds,r2_ix_45(&ds,a3,a2),/*IC*/(T2)(INT8_C(1)))),"needed_capacity >= up - low + 1");
fd.assertion_flag=1;
}
if(((ds.p=0x08604228/*l66c20/array.e*/),(T6)(((_value,0))&&((T6)(((int32_t)((/*RF2*/(C)->_capacity/*i4p*/)))>(/*IC*/(T2)(INT8_C(0)))))))){
(ds.p=0x0860440A/*l68c5/array.e*/);
r123clear_all(&ds,C);
}
(ds.p=0x08604608/*l70c4/array.e*/);
/*SFN*/(C->_lower/*i4p*/)=a2;
(ds.p=0x08604708/*l71c4/array.e*/);
/*SFN*/(C->_upper/*i4p*/)=a3;
if(((ds.p=0x0860482E/*l72c23/array.e*/),((int32_t)(a1))>(/*IC*/(T2)(INT8_C(0))))){
if(((ds.p=0x08604922/*l73c17/array.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i4p*/)))<(a1))){
(ds.p=0x08604A0C/*l74c6/array.e*/);
/*SFN*/(C->_storage/*i4p*/)=new124(a1);
(ds.p=0x08604B0C/*l75c6/array.e*/);
/*SFN*/(C->_capacity/*i4p*/)=a1;
}
else if(((ds.p=0x08604C34/*l76c26/array.e*/),(T6)(((_value,1))&&((T6)(((int32_t)(a3))>=(a2)))))){
(ds.p=0x08604E0C/*l78c6/array.e*/);
r123clear_all(&ds,C);
}
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08605228/*l82c20/array.e*/);
ac_ens(((int32_t)(a1))<=((/*RF2*/(C)->_capacity/*i4p*/)),"needed_capacity <= capacity");
(ds.p=0x08605308/*l83c4/array.e*/);
ac_ens(((/*RF2*/(C)->_lower/*i4p*/))==(a2),"lower = low");
(ds.p=0x08605408/*l84c4/array.e*/);
ac_ens(((/*RF2*/(C)->_upper/*i4p*/))==(a3),"upper = up");
(ds.p=0x08605508/*l85c4/array.e*/);
ac_ens(r123all_default(&ds,C),"all_default");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123make(se_dump_stack*caller,T123* C,T2 a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"make"" ARRAY[INTEGER_32]",1,2,"%R123%min_index%E2%max_index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08601F04/*l31c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08602438/*l36c28/array.e*/);
ac_req(((int32_t)(a1))<=(r2_ix_43(&ds,a2,/*IC*/(T2)(INT8_C(1)))),"valid_bounds");
fd.assertion_flag=1;
}
(ds.p=0x08602608/*l38c4/array.e*/);
r123ensure_capacity_and_bounds(&ds,C,r2_ix_43(&ds,r2_ix_45(&ds,a2,a1),/*IC*/(T2)(INT8_C(1))),a1,a2);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0860281E/*l40c15/array.e*/);
ac_ens(((/*RF2*/(C)->_lower/*i4p*/))==(a1),"lower_set");
(ds.p=0x0860291E/*l41c15/array.e*/);
ac_ens(((/*RF2*/(C)->_upper/*i4p*/))==(a2),"upper_set");
(ds.p=0x08602A1E/*l42c15/array.e*/);
ac_ens(r123all_default(&ds,C),"items_set");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/T2 r123count(se_dump_stack*caller,T123* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count"" ARRAY[INTEGER_32]",1,1,"%R123%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08609B04/*l155c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x08609D08/*l157c4/array.e*/);
R=r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),(/*RF2*/(C)->_lower/*i4p*/)),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04003620/*l54c16/traversable.e*/);
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),(/*RF2*/(C)->_lower/*i4p*/)),/*IC*/(T2)(INT8_C(1)))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/T2 r123last(se_dump_stack*caller,T123* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"last"" ARRAY[INTEGER_32]",1,1,"%R123%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08A02B04/*l43c2/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04005C08/*l92c4/traversable.e*/);
ac_req(r6_px_not(&ds,(T6)(r123is_empty(&ds,C))),"not is_empty");
fd.assertion_flag=1;
}
(ds.p=0x08A02D08/*l45c4/arrayed_collection.e*/);
R=r123item(&ds,C,(/*RF2*/(C)->_upper/*i4p*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04005F20/*l95c16/traversable.e*/);
ac_ens((R)==(r123item(&ds,C,(/*RF2*/(C)->_upper/*i4p*/))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/T6 r123valid_index(se_dump_stack*caller,T123* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index"" ARRAY[INTEGER_32]",1,2,"%R123%i%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04002504/*l37c2/traversable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04002A08/*l42c4/traversable.e*/);
R=((T6)((T6)((((int32_t)((/*RF2*/(C)->_lower/*i4p*/)))<=(a1))&&((T6)(((int32_t)(a1))<=((/*RF2*/(C)->_upper/*i4p*/)))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04002C20/*l44c16/traversable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(((int32_t)((/*RF2*/(C)->_lower/*i4p*/)))<=(a1)),(T6)(((int32_t)(a1))<=((/*RF2*/(C)->_upper/*i4p*/))))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/T6 r123is_empty(se_dump_stack*caller,T123* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty"" ARRAY[INTEGER_32]",1,1,"%R123%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0860A004/*l160c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0860A208/*l162c4/array.e*/);
R=((T6)(((int32_t)((/*RF2*/(C)->_upper/*i4p*/)))<((/*RF2*/(C)->_lower/*i4p*/))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04003F20/*l63c16/traversable.e*/);
ac_ens((R)==((r123count(&ds,C))==(INT8_C(0))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/T2 r123item(se_dump_stack*caller,T123* C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"item"" ARRAY[INTEGER_32]",1,2,"%R123%i%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0860AD04/*l173c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04004808/*l72c4/traversable.e*/);
ac_req(r123valid_index(&ds,C,a1),"valid_index(i)");
fd.assertion_flag=1;
}
(ds.p=0x0860AF08/*l175c4/array.e*/);
R=((/*RF2*/(C)->_storage/*i4p*/))[r2_ix_45(&ds,a1,(/*RF2*/(C)->_lower/*i4p*/))];
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/void r123move(se_dump_stack*caller,T123* C,T2 a1,T2 a2,T2 a3){
T2 _default_value=0;
T2 _i=0;
T2 o64_632_12=0;
void**locals[6];
static se_frame_descriptor fd={"move"" ARRAY[INTEGER_32]",1,6,"%R123%lower_index%E2%upper_index%E2%distance%E2%default_value%E2%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08025204/*l594c2/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
locals[3]=(void**)&_default_value;
locals[4]=(void**)&_i;
locals[5]=(void**)&o64_632_12;
set_dump_stack_top(&ds);/*link*/
o64_632_12=r123count(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08025920/*l601c16/collection.e*/);
ac_req(((int32_t)(a1))<=(a2),"lower_index <= upper_index");
(ds.p=0x08025A08/*l602c4/collection.e*/);
ac_req(r123valid_index(&ds,C,a1),"valid_index(lower_index)");
(ds.p=0x08025B08/*l603c4/collection.e*/);
ac_req(r123valid_index(&ds,C,r2_ix_43(&ds,a1,a3)),"valid_index(lower_index + distance)");
(ds.p=0x08025C08/*l604c4/collection.e*/);
ac_req(r123valid_index(&ds,C,a2),"valid_index(upper_index)");
(ds.p=0x08025D08/*l605c4/collection.e*/);
ac_req(r123valid_index(&ds,C,r2_ix_43(&ds,a2,a3)),"valid_index(upper_index + distance)");
fd.assertion_flag=1;
}
if(((ds.p=0x0802610E/*l609c7/collection.e*/),(a3)==(INT8_C(0)))){
}
else if(((ds.p=0x08026228/*l610c20/collection.e*/),((int32_t)(a3))<(/*IC*/(T2)(INT8_C(0))))){
(ds.p=0x0802640C/*l612c6/collection.e*/);
_i=a1;
while (!(((ds.p=0x08026610/*l614c8/collection.e*/),((int32_t)(_i))>(a2))))
{
(ds.p=0x0802680C/*l616c6/collection.e*/);
r123put(&ds,C,r123item(&ds,C,_i),r2_ix_43(&ds,_i,a3));
(ds.p=0x0802690C/*l617c6/collection.e*/);
r123put(&ds,C,_default_value,_i);
(ds.p=0x08026A0C/*l618c6/collection.e*/);
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
}
else{
(ds.p=0x08026E0C/*l622c6/collection.e*/);
_i=a2;
while (!(((ds.p=0x08027010/*l624c8/collection.e*/),((int32_t)(_i))<(a1))))
{
(ds.p=0x0802720C/*l626c6/collection.e*/);
r123put(&ds,C,r123item(&ds,C,_i),r2_ix_43(&ds,_i,a3));
(ds.p=0x0802730C/*l627c6/collection.e*/);
r123put(&ds,C,_default_value,_i);
(ds.p=0x0802740C/*l628c6/collection.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08027808/*l632c4/collection.e*/);
ac_ens((r123count(&ds,C))==(o64_632_12),"count = old count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/void r123put(se_dump_stack*caller,T123* C,T2 a1,T2 a2){
T2 o64_54_12=0;
void**locals[3];
static se_frame_descriptor fd={"put"" ARRAY[INTEGER_32]",1,3,"%R123%element%E2%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0860B204/*l178c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&o64_54_12;
set_dump_stack_top(&ds);/*link*/
o64_54_12=r123count(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08003208/*l50c4/collection.e*/);
ac_req(r123valid_index(&ds,C,a2),"valid_index(i)");
fd.assertion_flag=1;
}
(ds.p=0x0860B418/*l180c12/array.e*/);
((/*RF2*/(C)->_storage/*i4p*/))[r2_ix_45(&ds,a2,(/*RF2*/(C)->_lower/*i4p*/))]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08003508/*l53c4/collection.e*/);
ac_ens((r123item(&ds,C,a2))==(a1),"item(i) = element");
(ds.p=0x08003608/*l54c4/collection.e*/);
ac_ens((r123count(&ds,C))==(o64_54_12),"count = old count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*ARRAY[INTEGER_32]*/T6 r123all_default(se_dump_stack*caller,T123* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"all_default"" ARRAY[INTEGER_32]",1,1,"%R123%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08613004/*l304c2/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x08613208/*l306c4/array.e*/);
R=((T6)(r124all_default(&ds,(/*RF2*/(C)->_storage/*i4p*/),r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),(/*RF2*/(C)->_lower/*i4p*/)))));
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/void r123clear_all(se_dump_stack*caller,T123* C){
T2 _value=0;
T2 o64_117_26=0;
T2 o64_118_26=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" ARRAY[INTEGER_32]",1,3,"%R123%value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08006C04/*l108c2/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_value;
locals[1]=(void**)&o64_117_26;
locals[2]=(void**)&o64_118_26;
set_dump_stack_top(&ds);/*link*/
o64_117_26=(/*RF2*/(C)->_upper/*i4p*/);
o64_118_26=(/*RF2*/(C)->_lower/*i4p*/);
(ds.p=0x08007308/*l115c4/collection.e*/);
r123set_all_with(&ds,C,_value);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x08007524/*l117c18/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*i4p*/))==(o64_117_26),"stable_upper");
(ds.p=0x08007624/*l118c18/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*i4p*/))==(o64_118_26),"stable_lower");
(ds.p=0x08007708/*l119c4/collection.e*/);
ac_ens(r123all_default(&ds,C),"all_default");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i123(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/
se_frame_descriptor se_ifd123={"invariant ARRAY[INTEGER_32]",1,0,"%R123%",1};

T123*se_i123(se_dump_stack*caller,T123*C){
se_dump_stack ds;
ds.fd=&se_ifd123;
ds.current=((void*)&C);
ds.p=0x08029C02/*l668c1/collection.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x08029D2C/*l669c22/collection.e*/);
ac_inv(((int32_t)((/*RF2*/(C)->_lower/*i4p*/)))<=(r2_ix_43(&ds,(/*RF2*/(C)->_upper/*i4p*/),/*IC*/(T2)(INT8_C(1)))),"valid_bounds");
(ds.p=0x08A07516/*l117c11/arrayed_collection.e*/);
ac_inv(((int32_t)((/*RF2*/(C)->_capacity/*i4p*/)))>=(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*i4p*/),(/*RF2*/(C)->_lower/*i4p*/)),/*IC*/(T2)(INT8_C(1)))),"capacity >= upper - lower + 1");
(ds.p=0x08A0761E/*l118c15/arrayed_collection.e*/);
ac_inv((T6)((!(((int32_t)((/*RF2*/(C)->_capacity/*i4p*/)))>(/*IC*/(T2)(INT8_C(0)))))||((T6)(r124is_not_null(&ds,(/*RF2*/(C)->_storage/*i4p*/))))),"capacity > 0 implies storage.is_not_null");
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}/*--*/

/*STD_INPUT*/T3 r48last_character(se_dump_stack*caller,T48* C){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"last_character"" STD_INPUT",1,1,"%R48%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05602D04/*l45c2/input_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05802F08/*l47c4/input_stream_tools.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05803008/*l48c4/input_stream_tools.e*/);
ac_req(r6_px_not(&ds,(T6)((/*RF2*/(C)->_end_of_input/*i9p*/))),"not end_of_input");
(ds.p=0x05803128/*l49c20/input_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r48is_filtered(&ds,C))))&&((T6)(/*RF1valid_last_character*/1))),"not is_filtered and then valid_last_character");
fd.assertion_flag=1;
}
(ds.p=0x05602F08/*l47c4/input_stream.e*/);
R=(/*RF2*/(C)->_filtered_last_character/*i9p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05603108/*l49c4/input_stream.e*/);
ac_ens(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05603208/*l50c4/input_stream.e*/);
ac_ens(r6_px_not(&ds,(T6)((/*RF2*/(C)->_end_of_input/*i9p*/))),"not end_of_input");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT*/void r48unread_character(se_dump_stack*caller,T48* C){
static se_frame_descriptor fd={"unread_character"" STD_INPUT",1,0,"%R48%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05602604/*l38c2/input_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05802808/*l40c4/input_stream_tools.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05802928/*l41c20/input_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r48is_filtered(&ds,C))))&&((T6)(r48can_unread_character(&ds,C)))),"not is_filtered and then can_unread_character");
fd.assertion_flag=1;
}
(ds.p=0x05602808/*l40c4/input_stream.e*/);
r48filtered_unread_character(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05602A08/*l42c4/input_stream.e*/);
ac_ens(r6_px_not(&ds,(T6)((/*RF2*/(C)->_end_of_input/*i9p*/))),"not end_of_input");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/
T0*oBC13std_output=(void*)0;
int fBC13std_output=0;

/*STD_INPUT*/T0* r48std_output(se_dump_stack*caller,T48* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"std_output"" STD_INPUT",1,1,"%R48%Result%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A0B104/*l177c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC13std_output;
set_dump_stack_top(&ds);/*link*/
if(fBC13std_output==0){fBC13std_output=1;{
(ds.p=0x01A0B408/*l180c4/any.e*/);
tmp0=((T0*)(new47()));
r47make(&ds,((T47*)tmp0));
oBC13std_output=tmp0;
}
fBC13std_output=2;}
else{
(ds.p=0x01A0B104/*l177c2/any.e*/);
ac_req(fBC13std_output==2, "Recursive once function.");
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A0B608/*l182c4/any.e*/);
ac_ens((oBC13std_output)!=((void*)((void*)0)),"Result /= Void");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return oBC13std_output;
}/*--*/

/*STD_INPUT*/T3 r48filtered_last_character(se_dump_stack*caller,T48* C){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"filtered_last_character"" STD_INPUT",1,1,"%R48%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06004904/*l73c2/std_input.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05604E08/*l78c4/input_stream.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05604F08/*l79c4/input_stream.e*/);
ac_req(/*RF1valid_last_character*/1,"valid_last_character");
fd.assertion_flag=1;
}
R=C->_filtered_last_character/*i9p*/;
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT*/void r48filtered_read_character(se_dump_stack*caller,T48* C){
static se_frame_descriptor fd={"filtered_read_character"" STD_INPUT",1,0,"%R48%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06003604/*l54c2/std_input.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05604008/*l64c4/input_stream.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05604108/*l65c4/input_stream.e*/);
ac_req(/*RF1can_read_character*/1,"can_read_character");
fd.assertion_flag=1;
}
(ds.p=0x0600381E/*l56c15/std_input.e*/);
r47flush(&ds,((T47*)ci(47,r48std_output(&ds,C),0x06003808/*l56c4/std_input.e*/)));
(ds.p=0x06003908/*l57c4/std_input.e*/);
/*SFN*/(C->_unread_character_flag/*i9p*/)=((T6)(0));
if(((ds.p=0x06003A2E/*l58c23/std_input.e*/),((int32_t)((/*RF2*/(C)->_buffer_position/*i9p*/)))>=((/*RF2*/(C)->_buffer_size/*i9p*/)))){
(ds.p=0x06003B0A/*l59c5/std_input.e*/);
r48fill_buffer(&ds,C);
}
(ds.p=0x06003D08/*l61c4/std_input.e*/);
/*SFN*/(C->_filtered_last_character/*i9p*/)=((/*RF2*/(C)->_buffer/*i9p*/))[(/*RF2*/(C)->_buffer_position/*i9p*/)];
(ds.p=0x06003E08/*l62c4/std_input.e*/);
/*SFN*/(C->_buffer_position/*i9p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_buffer_position/*i9p*/),/*IC*/(T2)(INT8_C(1)));
(ds.p=0x06003F08/*l63c4/std_input.e*/);
/*SFN*/(C->_end_of_input/*i9p*/)=((T6)((/*RF2*/(C)->_end_reached/*i9p*/)));
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT*/void r48filtered_unread_character(se_dump_stack*caller,T48* C){
static se_frame_descriptor fd={"filtered_unread_character"" STD_INPUT",1,0,"%R48%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06004204/*l66c2/std_input.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05604708/*l71c4/input_stream.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05604808/*l72c4/input_stream.e*/);
ac_req(r48can_unread_character(&ds,C),"can_unread_character");
fd.assertion_flag=1;
}
(ds.p=0x06004408/*l68c4/std_input.e*/);
/*SFN*/(C->_unread_character_flag/*i9p*/)=((T6)(1));
(ds.p=0x06004508/*l69c4/std_input.e*/);
/*SFN*/(C->_end_of_input/*i9p*/)=((T6)(0));
(ds.p=0x06004608/*l70c4/std_input.e*/);
/*SFN*/(C->_buffer_position/*i9p*/)=r2_ix_45(&ds,(/*RF2*/(C)->_buffer_position/*i9p*/),/*IC*/(T2)(INT8_C(1)));
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT*/void r48make(se_dump_stack*caller,T48* C){
static se_frame_descriptor fd={"make"" STD_INPUT",1,0,"%R48%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06002904/*l41c2/std_input.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x06002B08/*l43c4/std_input.e*/);
/*SFN*/(C->_buffer/*i9p*/)=new9(/*IC*/(T2)(INT16_C(4096)));
(ds.p=0x06002C08/*l44c4/std_input.e*/);
/*SFN*/(C->_capacity/*i9p*/)=/*IC*/(T2)(INT16_C(4096));
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT*/T6 r48is_filtered(se_dump_stack*caller,T48* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_filtered"" STD_INPUT",1,1,"%R48%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03A01D04/*l29c2/filterable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03A02008/*l32c4/filterable.e*/);
R=((T6)(((/*RF2*/(C)->_filter/*i9p*/))!=((void*)((void*)0))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT*/void r48fill_buffer(se_dump_stack*caller,T48* C){
T3 _last=0;
void**locals[1];
static se_frame_descriptor fd={"fill_buffer"" STD_INPUT",1,1,"%R48%last%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06008804/*l136c2/std_input.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_last;
set_dump_stack_top(&ds);/*link*/
if(((ds.p=0x06008C26/*l140c19/std_input.e*/),((int32_t)((/*RF2*/(C)->_buffer_size/*i9p*/)))>(/*IC*/(T2)(INT8_C(0))))){
(ds.p=0x06008D0A/*l141c5/std_input.e*/);
_last=((/*RF2*/(C)->_buffer/*i9p*/))[r2_ix_45(&ds,(/*RF2*/(C)->_buffer_size/*i9p*/),/*IC*/(T2)(INT8_C(1)))];
}
(ds.p=0x06008F08/*l143c4/std_input.e*/);
/*SFN*/(C->_buffer_size/*i9p*/)=read_stdin((/*RF2*/(C)->_buffer/*i9p*/),/*IC*/(T2)(INT16_C(4096)));
(ds.p=0x06009008/*l144c4/std_input.e*/);
/*SFN*/(C->_buffer_position/*i9p*/)=/*IC*/(T2)(INT8_C(0));
if(((ds.p=0x06009126/*l145c19/std_input.e*/),((int32_t)((/*RF2*/(C)->_buffer_size/*i9p*/)))<=(/*IC*/(T2)(INT8_C(0))))){
(ds.p=0x0600920A/*l146c5/std_input.e*/);
/*SFN*/(C->_end_reached/*i9p*/)=((T6)(1));
(ds.p=0x06009318/*l147c12/std_input.e*/);
((/*RF2*/(C)->_buffer/*i9p*/))[/*IC*/(T2)(INT8_C(0))]=(_last);
(ds.p=0x0600960A/*l150c5/std_input.e*/);
/*SFN*/(C->_buffer_size/*i9p*/)=/*IC*/(T2)(INT8_C(1));
(ds.p=0x0600970A/*l151c5/std_input.e*/);
/*SFN*/(C->_buffer_position/*i9p*/)=/*IC*/(T2)(INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT*/void r48read_character(se_dump_stack*caller,T48* C){
static se_frame_descriptor fd={"read_character"" STD_INPUT",1,0,"%R48%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05601504/*l21c2/input_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05800A08/*l10c4/input_stream_tools.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05800B28/*l11c20/input_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r48is_filtered(&ds,C))))&&((T6)(/*RF1can_read_character*/1))),"not is_filtered and then can_read_character");
fd.assertion_flag=1;
}
(ds.p=0x05601708/*l23c4/input_stream.e*/);
r48filtered_read_character(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05601908/*l25c4/input_stream.e*/);
ac_ens(/*RF1is_connected*/1,"is_connected");
(ds.p=0x05800E2A/*l14c21/input_stream_tools.e*/);
ac_ens((T6)((!(r6_px_not(&ds,(T6)((/*RF2*/(C)->_end_of_input/*i9p*/)))))||((T6)(r48can_unread_character(&ds,C)))),"not end_of_input implies can_unread_character");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT*/T6 r48can_unread_character(se_dump_stack*caller,T48* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"can_unread_character"" STD_INPUT",1,1,"%R48%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06003004/*l48c2/std_input.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05805308/*l83c4/input_stream_tools.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
fd.assertion_flag=1;
}
(ds.p=0x06003208/*l50c4/std_input.e*/);
R=((T6)(r6_px_not(&ds,(T6)((/*RF2*/(C)->_unread_character_flag/*i9p*/)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_OUTPUT*/T0* r47std_output(se_dump_stack*caller,T47* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"std_output"" STD_OUTPUT",1,1,"%R47%Result%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A0B104/*l177c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC13std_output;
set_dump_stack_top(&ds);/*link*/
if(fBC13std_output==0){fBC13std_output=1;{
(ds.p=0x01A0B408/*l180c4/any.e*/);
tmp0=((T0*)(new47()));
r47make(&ds,((T47*)tmp0));
oBC13std_output=tmp0;
}
fBC13std_output=2;}
else{
(ds.p=0x01A0B104/*l177c2/any.e*/);
ac_req(fBC13std_output==2, "Recursive once function.");
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A0B608/*l182c4/any.e*/);
ac_ens((oBC13std_output)!=((void*)((void*)0)),"Result /= Void");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return oBC13std_output;
}/*--*/

/*STD_OUTPUT*/void r47se_atexit(se_dump_stack*caller,T47* C){
static se_frame_descriptor fd={"se_atexit"" STD_OUTPUT",1,0,"%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A18304/*l387c2/any.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01A1871E/*l391c15/any.e*/);
r47flush(&ds,((T47*)ci(47,r47std_output(&ds,C),0x01A18708/*l391c4/any.e*/)));
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_OUTPUT*/void r47make(se_dump_stack*caller,T47* C){
static se_frame_descriptor fd={"make"" STD_OUTPUT",1,0,"%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05E02604/*l38c2/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x05E02808/*l40c4/std_output.e*/);
/*SFN*/(C->_buffer/*i4p*/)=new9(/*IC*/(T2)(INT16_C(4096)));
(ds.p=0x05E02908/*l41c4/std_output.e*/);
/*SFN*/(C->_capacity/*i4p*/)=/*IC*/(T2)(INT16_C(4096));
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_OUTPUT*/T6 r47is_filtered(se_dump_stack*caller,T47* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_filtered"" STD_OUTPUT",1,1,"%R47%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03A01D04/*l29c2/filterable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03A02008/*l32c4/filterable.e*/);
R=((T6)(((/*RF2*/(C)->_filter/*i4p*/))!=((void*)((void*)0))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_OUTPUT*/void r47write_buffer(se_dump_stack*caller,T47* C){
static se_frame_descriptor fd={"write_buffer"" STD_OUTPUT",1,0,"%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05E07B04/*l123c2/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(((ds.p=0x05E07D2E/*l125c23/std_output.e*/),((int32_t)((/*RF2*/(C)->_buffer_position/*i4p*/)))>(/*IC*/(T2)(INT8_C(0))))){
(ds.p=0x05E07E0A/*l126c5/std_output.e*/);
io_fwrite((/*RF2*/(C)->_buffer/*i4p*/),(/*RF2*/(C)->_buffer_position/*i4p*/),stdout);
(ds.p=0x05E07F0A/*l127c5/std_output.e*/);
/*SFN*/(C->_buffer_position/*i4p*/)=/*IC*/(T2)(INT8_C(0));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_OUTPUT*/void r47put_character(se_dump_stack*caller,T47* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"put_character"" STD_OUTPUT",1,1,"%R47%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03401304/*l19c2/output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03C00B08/*l11c4/output_stream_tools.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x03C00C28/*l12c20/output_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r47is_filtered(&ds,C))))&&((T6)(r47can_put_character(&ds,C,a1)))),"not is_filtered and then can_put_character(c)");
fd.assertion_flag=1;
}
(ds.p=0x03401508/*l21c4/output_stream.e*/);
r47filtered_put_character(&ds,C,a1);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_OUTPUT*/void r47flush(se_dump_stack*caller,T47* C){
static se_frame_descriptor fd={"flush"" STD_OUTPUT",1,0,"%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03401804/*l24c2/output_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03C01408/*l20c4/output_stream_tools.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
fd.assertion_flag=1;
}
if(((ds.p=0x03401C0E/*l28c7/output_stream.e*/),((/*RF2*/(C)->_filter/*i4p*/))!=((void*)((void*)0)))){
(ds.p=0x03401D18/*l29c12/output_stream.e*/);
se_evobt((/*RF2*/(C)->_filter/*i4p*/),0x03401D0A/*l29c5/output_stream.e*/);
}
else{
(ds.p=0x03401F0A/*l31c5/output_stream.e*/);
r47filtered_flush(&ds,C);
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_OUTPUT*/T6 r47can_put_character(se_dump_stack*caller,T47* C,T3 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"can_put_character"" STD_OUTPUT",1,2,"%R47%c%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04C01104/*l17c2/terminal_output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04C01308/*l19c4/terminal_output_stream.e*/);
R=((T6)(1));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_OUTPUT*/void r47filtered_flush(se_dump_stack*caller,T47* C){
static se_frame_descriptor fd={"filtered_flush"" STD_OUTPUT",1,0,"%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05E03904/*l57c2/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03403A08/*l58c4/output_stream.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
fd.assertion_flag=1;
}
if(((ds.p=0x05E03B2E/*l59c23/std_output.e*/),((int32_t)((/*RF2*/(C)->_buffer_position/*i4p*/)))>(/*IC*/(T2)(INT8_C(0))))){
(ds.p=0x05E03C0A/*l60c5/std_output.e*/);
r47write_buffer(&ds,C);
}
(ds.p=0x05E03E08/*l62c4/std_output.e*/);
io_flush(stdout);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_OUTPUT*/void r47filtered_put_character(se_dump_stack*caller,T47* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"filtered_put_character"" STD_OUTPUT",1,1,"%R47%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05E02D04/*l45c2/std_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03403308/*l51c4/output_stream.e*/);
ac_req(/*RF1is_connected*/1,"is_connected");
(ds.p=0x03403408/*l52c4/output_stream.e*/);
ac_req(r47can_put_character(&ds,C,a1),"can_put_character(c)");
fd.assertion_flag=1;
}
if(((ds.p=0x05E02F2E/*l47c23/std_output.e*/),((int32_t)((/*RF2*/(C)->_buffer_position/*i4p*/)))>=(/*IC*/(T2)(INT16_C(4096))))){
(ds.p=0x05E0300A/*l48c5/std_output.e*/);
r47write_buffer(&ds,C);
}
(ds.p=0x05E03216/*l50c11/std_output.e*/);
((/*RF2*/(C)->_buffer/*i4p*/))[(/*RF2*/(C)->_buffer_position/*i4p*/)]=(a1);
(ds.p=0x05E03308/*l51c4/std_output.e*/);
/*SFN*/(C->_buffer_position/*i4p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_buffer_position/*i4p*/),/*IC*/(T2)(INT8_C(1)));
if(((ds.p=0x05E0340E/*l52c7/std_output.e*/),(a1)==(((T3)'\n')))){
(ds.p=0x05E0350A/*l53c5/std_output.e*/);
r47write_buffer(&ds,C);
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*INTEGER_16*/T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal"" INTEGER_16",1,2,"%E10%other%E10%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06431804/*l792c2/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A03608/*l54c4/any.e*/);
ac_req((a1,1),"other /= Void");
fd.assertion_flag=1;
}
(ds.p=0x06431A08/*l794c4/integer_general.e*/);
R=((T6)((C)==(a1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A03972/*l57c57/any.e*/);
ac_ens((T6)((!(((T0*)(t[10]))==((void*)((T0*)(t[10])))))||((T6)((R)==(r10is_equal(&ds,a1,C))))),"commutative");
(ds.p=0x04601C16/*l28c11/hashable.e*/);
ac_ens((T6)((!(R))||((T6)((r10hash_code(&ds,C))==(r10hash_code(&ds,a1))))),"Result implies hash_code = other.hash_code");
(ds.p=0x04401320/*l19c16/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(r6_px_not(&ds,(T6)(((int16_t)(C))<(a1)))),(T6)(r6_px_not(&ds,(T6)(((int16_t)(a1))<(C)))))),"trichotomy");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_16*/T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"in_range"" INTEGER_16",1,3,"%E10%lower%E10%upper%E10%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04404504/*l69c2/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04404A08/*l74c4/comparable.e*/);
R=((T6)((T6)((((int16_t)(C))>=(a1))&&((T6)(((int16_t)(C))<=(a2))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04404C08/*l76c4/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(((int16_t)(C))>=(a1)),(T6)(((int16_t)(C))<=(a2)))),"Result = (Current >= lower and Current <= upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_16*/T2 r10hash_code(se_dump_stack*caller,T10 C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"hash_code"" INTEGER_16",1,1,"%E10%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01406A04/*l106c2/integer_16.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01406C08/*l108c4/integer_16.e*/);
R=/*IC*/(T2)((C&/*0x7FFF*/INT16_C(32767)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04601638/*l22c28/hashable.e*/);
ac_ens(((int32_t)(R))>=(/*IC*/(T2)(INT8_C(0))),"good_hash_value");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_16*/T1 r10to_integer_8(se_dump_stack*caller,T10 C){
T1 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_8"" INTEGER_16",1,1,"%E10%Result%E1%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01401704/*l23c2/integer_16.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01401A08/*l26c4/integer_16.e*/);
ac_req(r10fit_integer_8(&ds,C),"fit_integer_8");
fd.assertion_flag=1;
}
R=((EIF_INTEGER_8)C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01401D18/*l29c12/integer_16.e*/);
ac_ens(r10is_equal(&ds,C,/*IC*/(T10)(R)),"Current.is_equal(Result)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_16*/T6 r10fit_integer_8(se_dump_stack*caller,T10 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"fit_integer_8"" INTEGER_16",1,1,"%E10%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01400D04/*l13c2/integer_16.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(((ds.p=0x0140101E/*l16c15/integer_16.e*/),((int16_t)(C))>=(/*IC*/(T10)(INT8_MIN)))){
(ds.p=0x0140110A/*l17c5/integer_16.e*/);
R=((T6)(((int16_t)(C))<=(/*IC*/(T10)(INT8_C(127)))));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01401408/*l20c4/integer_16.e*/);
ac_ens((R)==(r10in_range(&ds,C,/*IC*/(T10)(INT8_MIN),/*IC*/(T10)(INT8_C(127)))),"Result = Current.in_range(-128, 127)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
T0*oBC13io=(void*)0;
int fBC13io=0;

/*TOWER*/T0* r49io(se_dump_stack*caller,T49* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"io"" TOWER",1,1,"%R49%Result%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A09F04/*l159c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC13io;
set_dump_stack_top(&ds);/*link*/
if(fBC13io==0){fBC13io=1;{
(ds.p=0x01A0A408/*l164c4/any.e*/);
tmp0=((T0*)(new40()));
r40make(&ds,((T40*)tmp0));
oBC13io=tmp0;
se_i40(&ds,((T40*)(oBC13io)));}
fBC13io=2;}
else{
(ds.p=0x01A09F04/*l159c2/any.e*/);
ac_req(fBC13io==2, "Recursive once function.");
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A0A608/*l166c4/any.e*/);
ac_ens((oBC13io)!=((void*)((void*)0)),"Result /= Void");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return oBC13io;
}/*--*/

/*TOWER*/void r49empty(se_dump_stack*caller,T49* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
void**locals[2];
static se_frame_descriptor fd={"empty"" TOWER",1,2,"%R49%n%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06202504/*l37c2/tower.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0620280C/*l40c6/tower.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(1))),"n >= 1");
fd.assertion_flag=1;
}
(ds.p=0x06202C08/*l44c4/tower.e*/);
tmp0=((T0*)(new123()));
r123make(&ds,((T123*)tmp0),/*IC*/(T2)(INT8_C(1)),a1);
/*SFN*/(C->_t/*i2p*/)=tmp0;
se_i123(&ds,((T123*)(/*SFN*/(C->_t/*i2p*/))));(ds.p=0x06202E0A/*l46c5/tower.e*/);
_i=/*IC*/(T2)(INT8_C(1));
while (!(((ds.p=0x0620300E/*l48c7/tower.e*/),((int32_t)(_i))>(a1))))
{
(ds.p=0x0620320E/*l50c7/tower.e*/);
r123put(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x0620320A/*l50c5/tower.e*/))),/*IC*/(T2)(INT8_C(0)),_i);
(ds.p=0x0620330A/*l51c5/tower.e*/);
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
(ds.p=0x06203508/*l53c4/tower.e*/);
/*SFN*/(C->_top/*i2p*/)=/*IC*/(T2)(INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06203808/*l56c4/tower.e*/);
ac_ens((r49height(&ds,C))==(a1),"height = n");
(ds.p=0x06203908/*l57c4/tower.e*/);
ac_ens(((/*RF2*/(C)->_top/*i2p*/))==(INT8_C(1)),"top = 1");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*TOWER*/void r49ajouter_disque(se_dump_stack*caller,T49* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"ajouter_disque"" TOWER",1,1,"%R49%d%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06208104/*l129c2/tower.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(((ds.p=0x06208528/*l133c20/tower.e*/),((int32_t)(r123item(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x06208510/*l133c8/tower.e*/))),(/*RF2*/(C)->_top/*i2p*/))))>=(a1))){
(ds.p=0x0620860E/*l134c7/tower.e*/);
r123add(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x0620860A/*l134c5/tower.e*/))),a1,(/*RF2*/(C)->_top/*i2p*/));
}
else{
(ds.p=0x06208810/*l136c8/tower.e*/);
r40put_string(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x0620880A/*l136c5/tower.e*/))),se_ms(22,s49_561432822));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06208D10/*l141c8/tower.e*/);
ac_ens(((int32_t)((/*RF2*/(C)->_top/*i2p*/)))<=(r49height(&ds,C)),"top <= height");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*TOWER*/T2 r49height(se_dump_stack*caller,T49* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"height"" TOWER",1,1,"%R49%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06203D04/*l61c2/tower.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x06204008/*l64c4/tower.e*/);
R=(/*RF2*/(se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x0620401C/*l64c14/tower.e*/))))->_upper/*i4p*/);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*TOWER*/T2 r49retirer_disque(se_dump_stack*caller,T49* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"retirer_disque"" TOWER",1,1,"%R49%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06207004/*l112c2/tower.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(((ds.p=0x06207330/*l115c24/tower.e*/),r6_ix_and(&ds,(T6)((r123item(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x0620730E/*l115c7/tower.e*/))),(/*RF2*/(C)->_top/*i2p*/)))!=(INT8_C(0))),(T6)(((int32_t)((/*RF2*/(C)->_top/*i2p*/)))>=(/*IC*/(T2)(INT8_C(1))))))){
(ds.p=0x0620750A/*l117c5/tower.e*/);
R=r123item(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x0620751E/*l117c15/tower.e*/))),(/*RF2*/(C)->_top/*i2p*/));
(ds.p=0x0620760E/*l118c7/tower.e*/);
r123remove_last(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x0620760A/*l118c5/tower.e*/))));
if(((ds.p=0x06207718/*l119c12/tower.e*/),((int32_t)((/*RF2*/(C)->_top/*i2p*/)))>(/*IC*/(T2)(INT8_C(1))))){
(ds.p=0x0620780C/*l120c6/tower.e*/);
/*SFN*/(C->_top/*i2p*/)=r2_ix_45(&ds,(/*RF2*/(C)->_top/*i2p*/),/*IC*/(T2)(INT8_C(1)));
}
}
else{
(ds.p=0x06207B10/*l123c8/tower.e*/);
r40put_string(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x06207B0A/*l123c5/tower.e*/))),se_ms(22,s49_1934402326));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06207E10/*l126c8/tower.e*/);
ac_ens(((int32_t)((/*RF2*/(C)->_top/*i2p*/)))>=(/*IC*/(T2)(INT8_C(1))),"top >= 1");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*TOWER*/void r49afficher_etage(se_dump_stack*caller,T49* C,T2 a1){
T2 _taille_disque=0;
T2 _taille_disque_max=0;
T2 _i=0;
void**locals[4];
static se_frame_descriptor fd={"afficher_etage"" TOWER",1,4,"%R49%d%E2%taille_disque%E2%taille_disque_max%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06204304/*l67c2/tower.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_taille_disque;
locals[2]=(void**)&_taille_disque_max;
locals[3]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0620460C/*l70c6/tower.e*/);
ac_req(((int32_t)(/*IC*/(T2)(INT8_C(1))))<=(a1),"1 <= d");
(ds.p=0x0620470C/*l71c6/tower.e*/);
ac_req(((int32_t)(a1))<=(r49height(&ds,C)),"d <= height");
fd.assertion_flag=1;
}
(ds.p=0x06204B08/*l75c4/tower.e*/);
_taille_disque=r123item(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x06204B2A/*l75c21/tower.e*/))),a1);
(ds.p=0x06204C08/*l76c4/tower.e*/);
_taille_disque_max=r49height(&ds,C);
(ds.p=0x06204E0A/*l78c5/tower.e*/);
_i=r2_ix_45(&ds,_taille_disque_max,_taille_disque);
while (!(((ds.p=0x0620500A/*l80c5/tower.e*/),(_i)==(INT8_C(0)))))
{
(ds.p=0x06205210/*l82c8/tower.e*/);
r40put_character(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x0620520A/*l82c5/tower.e*/))),((T3)'\040'));
(ds.p=0x0620530A/*l83c5/tower.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
(ds.p=0x0620560A/*l86c5/tower.e*/);
_i=_taille_disque;
while (!(((ds.p=0x0620580A/*l88c5/tower.e*/),(_i)==(INT8_C(0)))))
{
(ds.p=0x06205A10/*l90c8/tower.e*/);
r40put_character(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x06205A0A/*l90c5/tower.e*/))),((T3)'\075'));
(ds.p=0x06205B0A/*l91c5/tower.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
(ds.p=0x06205D0E/*l93c7/tower.e*/);
r40put_character(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x06205D08/*l93c4/tower.e*/))),((T3)'\174'));
(ds.p=0x06205F0A/*l95c5/tower.e*/);
_i=_taille_disque;
while (!(((ds.p=0x0620610A/*l97c5/tower.e*/),(_i)==(INT8_C(0)))))
{
(ds.p=0x06206310/*l99c8/tower.e*/);
r40put_character(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x0620630A/*l99c5/tower.e*/))),((T3)'\075'));
(ds.p=0x0620640A/*l100c5/tower.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
(ds.p=0x0620670A/*l103c5/tower.e*/);
_i=r2_ix_45(&ds,_taille_disque_max,_taille_disque);
while (!(((ds.p=0x0620690A/*l105c5/tower.e*/),(_i)==(INT8_C(0)))))
{
(ds.p=0x06206B10/*l107c8/tower.e*/);
r40put_character(&ds,se_i40(&ds,((T40*)ci(40,r49io(&ds,C),0x06206B0A/*l107c5/tower.e*/))),((T3)'\040'));
(ds.p=0x06206C0A/*l108c5/tower.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*TOWER*/void r49full(se_dump_stack*caller,T49* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
void**locals[2];
static se_frame_descriptor fd={"full"" TOWER",1,2,"%R49%n%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06201004/*l16c2/tower.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0620130C/*l19c6/tower.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(1))),"n >= 1");
fd.assertion_flag=1;
}
(ds.p=0x06201708/*l23c4/tower.e*/);
tmp0=((T0*)(new123()));
r123make(&ds,((T123*)tmp0),/*IC*/(T2)(INT8_C(1)),a1);
/*SFN*/(C->_t/*i2p*/)=tmp0;
se_i123(&ds,((T123*)(/*SFN*/(C->_t/*i2p*/))));(ds.p=0x0620190C/*l25c6/tower.e*/);
_i=/*IC*/(T2)(INT8_C(0));
while (!(((ds.p=0x06201B10/*l27c8/tower.e*/),((int32_t)(_i))>=(a1))))
{
(ds.p=0x06201D10/*l29c8/tower.e*/);
r123put(&ds,se_i123(&ds,((T123*)ci(123,(/*RF2*/(C)->_t/*i2p*/),0x06201D0C/*l29c6/tower.e*/))),r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1))),r2_ix_45(&ds,a1,_i));
(ds.p=0x06201E0C/*l30c6/tower.e*/);
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
(ds.p=0x0620200A/*l32c5/tower.e*/);
/*SFN*/(C->_top/*i2p*/)=a1;
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/void r40read_integer(se_dump_stack*caller,T40* C){
T2 _state=0;
T6 _sign=0;
T6 o44_268_4=0;
void**locals[3];
static se_frame_descriptor fd={"read_integer"" STD_INPUT_OUTPUT",1,3,"%R40%state%E2%sign%E6%old value%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0580C604/*l198c2/input_stream_tools.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_state;
locals[1]=(void**)&_sign;
locals[2]=(void**)&o44_268_4;
set_dump_stack_top(&ds);/*link*/
o44_268_4=r40end_of_input(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0580CB08/*l203c4/input_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x0580CC08/*l204c4/input_stream_tools.e*/);
ac_req(r6_px_not(&ds,(T6)(r40input_is_filtered(&ds,C))),"not is_filtered");
fd.assertion_flag=1;
}
while (!(((ds.p=0x0580D716/*l215c11/input_stream_tools.e*/),((int32_t)(_state))>(/*IC*/(T2)(INT8_C(2))))))
{
(ds.p=0x0580D90A/*l217c5/input_stream_tools.e*/);
r40read_character(&ds,C);
if(((ds.p=0x0580DA10/*l218c8/input_stream_tools.e*/),r40end_of_input(&ds,C))){
/*[INSPECT*/
{int inspect_tmp_1=((ds.p=0x0580DC0E/*l220c7/input_stream_tools.e*/),_state);
switch(inspect_tmp_1){
case 0:
case 1:
(ds.p=0x0580DE0E/*l222c7/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(4));
break;
case 2:
(ds.p=0x0580E00E/*l224c7/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(3));
break;
default:;
error1("Invalid inspect (nothing selected).",0x0580DB0C/*l219c6/input_stream_tools.e*/);
}
}/*INSPECT]*/
}
else{
/*[INSPECT*/
{int inspect_tmp_1=((ds.p=0x0580E50E/*l229c7/input_stream_tools.e*/),_state);
switch(inspect_tmp_1){
case 0:
if(((ds.p=0x0580E732/*l231c25/input_stream_tools.e*/),r3is_separator(&ds,r40last_character(&ds,C)))){
}
else if(((ds.p=0x0580E83A/*l232c29/input_stream_tools.e*/),r3is_digit(&ds,r40last_character(&ds,C)))){
(ds.p=0x0580E910/*l233c8/input_stream_tools.e*/);
/*SFN*/(C->_last_integer/*i5p*/)=/*IC*/(T2)(r3value(&ds,r40last_character(&ds,C)));
(ds.p=0x0580EA10/*l234c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(2));
}
else if(((ds.p=0x0580EB1C/*l235c14/input_stream_tools.e*/),(r40last_character(&ds,C))==(((T3)'\055')))){
(ds.p=0x0580EC10/*l236c8/input_stream_tools.e*/);
_sign=((T6)(1));
(ds.p=0x0580ED10/*l237c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(1));
}
else if(((ds.p=0x0580EE1C/*l238c14/input_stream_tools.e*/),(r40last_character(&ds,C))==(((T3)'\053')))){
(ds.p=0x0580EF10/*l239c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(1));
}
else{
(ds.p=0x0580F110/*l241c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(4));
}
break;
case 1:
if(((ds.p=0x0580F432/*l244c25/input_stream_tools.e*/),r3is_separator(&ds,r40last_character(&ds,C)))){
}
else if(((ds.p=0x0580F53A/*l245c29/input_stream_tools.e*/),r3is_digit(&ds,r40last_character(&ds,C)))){
(ds.p=0x0580F610/*l246c8/input_stream_tools.e*/);
/*SFN*/(C->_last_integer/*i5p*/)=/*IC*/(T2)(r3value(&ds,r40last_character(&ds,C)));
(ds.p=0x0580F710/*l247c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(2));
}
else{
(ds.p=0x0580F910/*l249c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(4));
}
break;
default:;
if(((ds.p=0x0580FC32/*l252c25/input_stream_tools.e*/),r3is_digit(&ds,r40last_character(&ds,C)))){
(ds.p=0x0580FD10/*l253c8/input_stream_tools.e*/);
/*SFN*/(C->_last_integer/*i5p*/)=r2_ix_43(&ds,r2_ix_42(&ds,(/*RF2*/(C)->_last_integer/*i5p*/),/*IC*/(T2)(INT8_C(10))),/*IC*/(T2)(r3value(&ds,r40last_character(&ds,C))));
}
else{
(ds.p=0x0580FF10/*l255c8/input_stream_tools.e*/);
_state=/*IC*/(T2)(INT8_C(3));
}
}
}/*INSPECT]*/
}
}
if(((ds.p=0x05810438/*l260c28/input_stream_tools.e*/),(T6)((r40can_unread_character(&ds,C))&&((T6)(r6_px_not(&ds,(T6)(r40end_of_input(&ds,C)))))))){
(ds.p=0x0581050A/*l261c5/input_stream_tools.e*/);
r40unread_character(&ds,C);
}
(ds.p=0x05810708/*l263c4/input_stream_tools.e*/);
/*SFN*/(C->_valid_last_integer/*i5p*/)=((T6)((_state)!=(INT8_C(4))));
if(((ds.p=0x0581080E/*l264c7/input_stream_tools.e*/),_sign)){
(ds.p=0x0581090A/*l265c5/input_stream_tools.e*/);
/*SFN*/(C->_last_integer/*i5p*/)=r2_px_45(&ds,(/*RF2*/(C)->_last_integer/*i5p*/));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05810C2A/*l268c21/input_stream_tools.e*/);
ac_ens((T6)((!(o44_268_4))||((T6)((T6)((r40end_of_input(&ds,C))&&((T6)(r6_px_not(&ds,(T6)((/*RF2*/(C)->_valid_last_integer/*i5p*/))))))))),"old end_of_input implies end_of_input and then not valid_last_integer");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/T3 r40last_character(se_dump_stack*caller,T40* C){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"last_character"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05602D04/*l45c2/input_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05802F08/*l47c4/input_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05803008/*l48c4/input_stream_tools.e*/);
ac_req(r6_px_not(&ds,(T6)(r40end_of_input(&ds,C))),"not end_of_input");
(ds.p=0x05803128/*l49c20/input_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r40input_is_filtered(&ds,C))))&&((T6)(/*RF1valid_last_character*/1))),"not is_filtered and then valid_last_character");
fd.assertion_flag=1;
}
(ds.p=0x05602F08/*l47c4/input_stream.e*/);
R=r40filtered_last_character(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05603108/*l49c4/input_stream.e*/);
ac_ens(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05603208/*l50c4/input_stream.e*/);
ac_ens(r6_px_not(&ds,(T6)(r40end_of_input(&ds,C))),"not end_of_input");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
T0*oBC13std_input=(void*)0;
int fBC13std_input=0;

/*STD_INPUT_OUTPUT*/T0* r40std_input(se_dump_stack*caller,T40* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"std_input"" STD_INPUT_OUTPUT",1,1,"%R40%Result%R48%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A0A904/*l169c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC13std_input;
set_dump_stack_top(&ds);/*link*/
if(fBC13std_input==0){fBC13std_input=1;{
(ds.p=0x01A0AC08/*l172c4/any.e*/);
tmp0=((T0*)(new48()));
r48make(&ds,((T48*)tmp0));
oBC13std_input=tmp0;
}
fBC13std_input=2;}
else{
(ds.p=0x01A0A904/*l169c2/any.e*/);
ac_req(fBC13std_input==2, "Recursive once function.");
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A0AE08/*l174c4/any.e*/);
ac_ens((oBC13std_input)!=((void*)((void*)0)),"Result /= Void");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return oBC13std_input;
}/*--*/

/*STD_INPUT_OUTPUT*/void r40unread_character(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"unread_character"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05602604/*l38c2/input_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05802808/*l40c4/input_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05802928/*l41c20/input_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r40input_is_filtered(&ds,C))))&&((T6)(r40can_unread_character(&ds,C)))),"not is_filtered and then can_unread_character");
fd.assertion_flag=1;
}
(ds.p=0x05602808/*l40c4/input_stream.e*/);
r40filtered_unread_character(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05602A08/*l42c4/input_stream.e*/);
ac_ens(r6_px_not(&ds,(T6)(r40end_of_input(&ds,C))),"not end_of_input");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/T3 r40filtered_last_character(se_dump_stack*caller,T40* C){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"filtered_last_character"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05003804/*l56c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05604E08/*l78c4/input_stream.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05604F08/*l79c4/input_stream.e*/);
ac_req(/*RF1valid_last_character*/1,"valid_last_character");
fd.assertion_flag=1;
}
(ds.p=0x05003A08/*l58c4/std_input_output.e*/);
R=r48last_character(&ds,((T48*)ci(48,r40std_input(&ds,C),0x05003A1C/*l58c14/std_input_output.e*/)));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/T0* r40std_output(se_dump_stack*caller,T40* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"std_output"" STD_INPUT_OUTPUT",1,1,"%R40%Result%R47%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A0B104/*l177c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC13std_output;
set_dump_stack_top(&ds);/*link*/
if(fBC13std_output==0){fBC13std_output=1;{
(ds.p=0x01A0B408/*l180c4/any.e*/);
tmp0=((T0*)(new47()));
r47make(&ds,((T47*)tmp0));
oBC13std_output=tmp0;
}
fBC13std_output=2;}
else{
(ds.p=0x01A0B104/*l177c2/any.e*/);
ac_req(fBC13std_output==2, "Recursive once function.");
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A0B608/*l182c4/any.e*/);
ac_ens((oBC13std_output)!=((void*)((void*)0)),"Result /= Void");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return oBC13std_output;
}/*--*/

/*STD_INPUT_OUTPUT*/void r40filtered_read_character(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"filtered_read_character"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05002E04/*l46c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05604008/*l64c4/input_stream.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05604108/*l65c4/input_stream.e*/);
ac_req(/*RF1can_read_character*/1,"can_read_character");
fd.assertion_flag=1;
}
(ds.p=0x0500301C/*l48c14/std_input_output.e*/);
r48read_character(&ds,((T48*)ci(48,r40std_input(&ds,C),0x05003008/*l48c4/std_input_output.e*/)));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/void r40filtered_unread_character(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"filtered_unread_character"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05003304/*l51c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05604708/*l71c4/input_stream.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05604808/*l72c4/input_stream.e*/);
ac_req(r40can_unread_character(&ds,C),"can_unread_character");
fd.assertion_flag=1;
}
(ds.p=0x0500351C/*l53c14/std_input_output.e*/);
r48unread_character(&ds,((T48*)ci(48,r40std_input(&ds,C),0x05003508/*l53c4/std_input_output.e*/)));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/T6 r40input_is_filtered(se_dump_stack*caller,T40* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_filtered"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03A01D04/*l29c2/filterable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03A02008/*l32c4/filterable.e*/);
R=((T6)(((/*RF2*/(C)->_input_filter/*i5p*/))!=((void*)((void*)0))));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/T6 r40output_is_filtered(se_dump_stack*caller,T40* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_filtered"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03A01D04/*l29c2/filterable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03A02008/*l32c4/filterable.e*/);
R=((T6)(((/*RF2*/(C)->_output_filter/*i5p*/))!=((void*)((void*)0))));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/void r40make(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"make"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05000F04/*l15c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/T6 r40is_connected(se_dump_stack*caller,T40* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_connected"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05001404/*l20c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x05001808/*l24c4/std_input_output.e*/);
R=((T6)((T6)(((T6)(((r40std_input(&ds,C))!=((void*)((void*)0)))&&((T6)(((/*UT*/(void)(((T48*)ci(48,r40std_input(&ds,C),0x05001852/*l24c41/std_input_output.e*/)))),/*RF1is_connected*/1)))))&&((T6)((T6)(((r40std_output(&ds,C))!=((void*)((void*)0)))&&((T6)(((/*UT*/(void)(((T47*)ci(47,r40std_output(&ds,C),0x05001956/*l25c43/std_input_output.e*/)))),/*RF1is_connected*/1)))))))));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/void r40put_character(se_dump_stack*caller,T40* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"put_character"" STD_INPUT_OUTPUT",1,1,"%R40%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03401304/*l19c2/output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03C00B08/*l11c4/output_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x03C00C28/*l12c20/output_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r40output_is_filtered(&ds,C))))&&((T6)(r40can_put_character(&ds,C,a1)))),"not is_filtered and then can_put_character(c)");
fd.assertion_flag=1;
}
(ds.p=0x03401508/*l21c4/output_stream.e*/);
r40filtered_put_character(&ds,C,a1);
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/void r40flush(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"flush"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03401804/*l24c2/output_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03C01408/*l20c4/output_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
fd.assertion_flag=1;
}
if(((ds.p=0x03401C0E/*l28c7/output_stream.e*/),((/*RF2*/(C)->_output_filter/*i5p*/))!=((void*)((void*)0)))){
(ds.p=0x03401D18/*l29c12/output_stream.e*/);
se_evobt((/*RF2*/(C)->_output_filter/*i5p*/),0x03401D0A/*l29c5/output_stream.e*/);
}
else{
(ds.p=0x03401F0A/*l31c5/output_stream.e*/);
r40filtered_flush(&ds,C);
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/void r40put_string(se_dump_stack*caller,T40* C,T0* a1){
T2 _i=0;
T2 _count=0;
void**locals[3];
static se_frame_descriptor fd={"put_string"" STD_INPUT_OUTPUT",1,3,"%R40%s%R7%i%E2%count%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x03C02504/*l37c2/output_stream_tools.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_i;
locals[2]=(void**)&_count;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03C02808/*l40c4/output_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x03C02908/*l41c4/output_stream_tools.e*/);
ac_req(r6_px_not(&ds,(T6)(r40output_is_filtered(&ds,C))),"not is_filtered");
(ds.p=0x03C02A08/*l42c4/output_stream_tools.e*/);
ac_req((a1)!=((void*)((void*)0)),"s /= Void");
fd.assertion_flag=1;
}
(ds.p=0x03C02F0A/*l47c5/output_stream_tools.e*/);
_i=/*IC*/(T2)(INT8_C(1));
(ds.p=0x03C0300A/*l48c5/output_stream_tools.e*/);
_count=r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x03C0301C/*l48c14/output_stream_tools.e*/))));
while (!(((ds.p=0x03C0320E/*l50c7/output_stream_tools.e*/),((int32_t)(_i))>(_count))))
{
(ds.p=0x03C0340A/*l52c5/output_stream_tools.e*/);
r40put_character(&ds,C,r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x03C03426/*l52c19/output_stream_tools.e*/))),_i));
(ds.p=0x03C0350A/*l53c5/output_stream_tools.e*/);
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/T6 r40can_put_character(se_dump_stack*caller,T40* C,T3 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"can_put_character"" STD_INPUT_OUTPUT",1,2,"%R40%c%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04C01104/*l17c2/terminal_output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04C01308/*l19c4/terminal_output_stream.e*/);
R=((T6)(1));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/void r40read_character(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"read_character"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05601504/*l21c2/input_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05800A08/*l10c4/input_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05800B28/*l11c20/input_stream_tools.e*/);
ac_req((T6)((r6_px_not(&ds,(T6)(r40input_is_filtered(&ds,C))))&&((T6)(/*RF1can_read_character*/1))),"not is_filtered and then can_read_character");
fd.assertion_flag=1;
}
(ds.p=0x05601708/*l23c4/input_stream.e*/);
r40filtered_read_character(&ds,C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05601908/*l25c4/input_stream.e*/);
ac_ens(r40is_connected(&ds,C),"is_connected");
(ds.p=0x05800E2A/*l14c21/input_stream_tools.e*/);
ac_ens((T6)((!(r6_px_not(&ds,(T6)(r40end_of_input(&ds,C)))))||((T6)(r40can_unread_character(&ds,C)))),"not end_of_input implies can_unread_character");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/T6 r40can_unread_character(se_dump_stack*caller,T40* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"can_unread_character"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05002804/*l40c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05805308/*l83c4/input_stream_tools.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
fd.assertion_flag=1;
}
(ds.p=0x05002A08/*l42c4/std_input_output.e*/);
R=((T6)(r48can_unread_character(&ds,((T48*)ci(48,r40std_input(&ds,C),0x05002A1C/*l42c14/std_input_output.e*/)))));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/T6 r40end_of_input(se_dump_stack*caller,T40* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"end_of_input"" STD_INPUT_OUTPUT",1,1,"%R40%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05002304/*l35c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x05002508/*l37c4/std_input_output.e*/);
R=((T6)((/*RF2*/(((T48*)ci(48,r40std_input(&ds,C),0x0500251C/*l37c14/std_input_output.e*/)))->_end_of_input/*i9p*/)));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STD_INPUT_OUTPUT*/void r40filtered_flush(se_dump_stack*caller,T40* C){
static se_frame_descriptor fd={"filtered_flush"" STD_INPUT_OUTPUT",1,0,"%R40%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05004304/*l67c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03403A08/*l58c4/output_stream.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
fd.assertion_flag=1;
}
(ds.p=0x0500451E/*l69c15/std_input_output.e*/);
r47flush(&ds,((T47*)ci(47,r40std_output(&ds,C),0x05004508/*l69c4/std_input_output.e*/)));
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STD_INPUT_OUTPUT*/void r40filtered_put_character(se_dump_stack*caller,T40* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"filtered_put_character"" STD_INPUT_OUTPUT",1,1,"%R40%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x05003E04/*l62c2/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03403308/*l51c4/output_stream.e*/);
ac_req(r40is_connected(&ds,C),"is_connected");
(ds.p=0x03403408/*l52c4/output_stream.e*/);
ac_req(r40can_put_character(&ds,C,a1),"can_put_character(c)");
fd.assertion_flag=1;
}
(ds.p=0x0500401E/*l64c15/std_input_output.e*/);
r47put_character(&ds,((T47*)ci(47,r40std_output(&ds,C),0x05004008/*l64c4/std_input_output.e*/)),a1);
if(se_rci(caller,C))se_i40(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/
se_frame_descriptor se_ifd40={"invariant STD_INPUT_OUTPUT",1,0,"%R40%",1};

T40*se_i40(se_dump_stack*caller,T40*C){
se_dump_stack ds;
ds.fd=&se_ifd40;
ds.current=((void*)&C);
ds.p=0x05005902/*l89c1/std_input_output.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x05005A4C/*l90c38/std_input_output.e*/);
ac_inv(r6_ix_and(&ds,(T6)(r6_px_not(&ds,(T6)(r40input_is_filtered(&ds,C)))),(T6)(r6_px_not(&ds,(T6)(r40output_is_filtered(&ds,C))))),"not_filtered");
(ds.p=0x05203904/*l57c2/terminal_input_output_stream.e*/);
ac_inv(((/*RF2*/(C)->_filter/*i5p*/))==((void*)((void*)0)),"filter = Void");
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}/*--*/

/*BOOLEAN*/T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix ""and"" (""infix ""and"" BOOLEAN)",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00C00E04/*l14c2/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C01508/*l21c4/boolean.e*/);
R=((T6)((T6)((C)&&((T6)(a1)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*BOOLEAN*/T6 r6_px_not(se_dump_stack*caller,T6 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"prefix ""not"" (""prefix ""not"" BOOLEAN)",1,1,"%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00C03714/*l55c10/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C03A08/*l58c4/boolean.e*/);
R=((T6)((C)==(0)));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*BOOLEAN*/T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix ""or"" (""infix ""or"" BOOLEAN)",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00C02204/*l34c2/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C02908/*l41c4/boolean.e*/);
R=((T6)((T6)((C)||((T6)(a1)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_8*/T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1){
T1 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix ""-"" (""infix ""-"" INTEGER_8)",1,2,"%E1%other%E1%Result%E1%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06402404/*l36c2/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06402658/*l38c44/integer_general.e*/);
ac_req((T6)((!((((int8_t)(C))>(INT8_C(0)))!=(((int8_t)(a1))>(INT8_C(0)))))||((T6)((((int8_t)(((int8_t)(C))-(a1)))>(INT8_C(0)))==(((int8_t)(C))>(INT8_C(0)))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x06402808/*l40c4/integer_general.e*/);
R=((int8_t)(C))-(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x06402A16/*l42c11/integer_general.e*/);
ac_ens((((int8_t)(R))+(a1))==(C),"Result #+ other = Current");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_8*/T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal"" INTEGER_8",1,2,"%E1%other%E1%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x06431804/*l792c2/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A03608/*l54c4/any.e*/);
ac_req((a1,1),"other /= Void");
fd.assertion_flag=1;
}
(ds.p=0x06431A08/*l794c4/integer_general.e*/);
R=((T6)((C)==(a1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A03972/*l57c57/any.e*/);
ac_ens((T6)((!(((T0*)(t[1]))==((void*)((T0*)(t[1])))))||((T6)((R)==(r1is_equal(&ds,a1,C))))),"commutative");
(ds.p=0x04601C16/*l28c11/hashable.e*/);
ac_ens((T6)((!(R))||((T6)((r1hash_code(&ds,C))==(r1hash_code(&ds,a1))))),"Result implies hash_code = other.hash_code");
(ds.p=0x04401320/*l19c16/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(r6_px_not(&ds,(T6)(((int8_t)(C))<(a1)))),(T6)(r6_px_not(&ds,(T6)(((int8_t)(a1))<(C)))))),"trichotomy");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_8*/T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"in_range"" INTEGER_8",1,3,"%E1%lower%E1%upper%E1%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04404504/*l69c2/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04404A08/*l74c4/comparable.e*/);
R=((T6)((T6)((((int8_t)(C))>=(a1))&&((T6)(((int8_t)(C))<=(a2))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04404C08/*l76c4/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(((int8_t)(C))>=(a1)),(T6)(((int8_t)(C))<=(a2)))),"Result = (Current >= lower and Current <= upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*INTEGER_8*/T2 r1hash_code(se_dump_stack*caller,T1 C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"hash_code"" INTEGER_8",1,1,"%E1%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00205404/*l84c2/integer_8.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00205608/*l86c4/integer_8.e*/);
R=/*IC*/(T2)((C&/*0x7F*/INT8_C(127)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04601638/*l22c28/hashable.e*/);
ac_ens(((int32_t)(R))>=(/*IC*/(T2)(INT8_C(0))),"good_hash_value");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

#ifdef __cplusplus
}
#endif
