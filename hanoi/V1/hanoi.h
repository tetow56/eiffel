#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3 (Thursday July 11th 2007) [Antoine-Auguste Parmentier]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1500) /* MSVC older than v9 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_GC_LIB 1
/* C Header Pass 1: */
typedef struct S123 T123;
typedef struct S48 T48;
typedef struct S47 T47;
typedef struct S49 T49;
typedef struct S40 T40;
typedef struct S25 T25;
typedef struct S7 T7;
/* C Header Pass 2: */
typedef T2*T124;
#define M124 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
/* C Header Pass 4: */
void se_prinT124(FILE* file,T124*o);
struct S123{Tid id;T124 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T123 M123;
void se_prinT123(FILE* file,T123**o);
struct S48{Tid id;T0* _filter;T6 _end_of_input;T3 _filtered_last_character;T9 _buffer;T6 _end_reached;T2 _buffer_size;T2 _buffer_position;T2 _capacity;T6 _unread_character_flag;};
extern T48 M48;
void se_prinT48(FILE* file,T48**o);
struct S47{Tid id;T0* _filter;T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T47 M47;
void se_prinT47(FILE* file,T47**o);
struct S49{Tid id;T0* _t;T2 _top;};
extern T49 M49;
void se_prinT49(FILE* file,T49**o);
struct S40{Tid id;T2 _last_integer;T6 _valid_last_integer;T0* _filter;T0* _output_filter;T0* _input_filter;};
extern T40 M40;
void se_prinT40(FILE* file,T40**o);
struct S25{Tid id;T2 _nb;T0* _tower3;T0* _tower2;T0* _tower1;};
extern T25 M25;
void se_prinT25(FILE* file,T25**o);
void se_prinT9(FILE* file,T9*o);
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
extern char*s25_10;
extern char*s49_561432822;
extern char*s25_378628469;
extern char*s25_213395088;
extern char*s49_1934402326;
extern char*s25_1632370714;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.h) is automatically included
  when `ace.no_check' is true (ie. all modes except mode -boost).
*/

void se_prinT0(FILE* file,T0** o);
void se_prinT1(FILE* file,EIF_INTEGER_8* o);
void se_prinT2(FILE* file,EIF_INTEGER* o);
void se_prinT3(FILE* file,EIF_CHARACTER* o);
void se_prinT4(FILE* file,EIF_REAL_32* o);
void se_prinT5(FILE* file,EIF_REAL_64* o);
void se_prinT12(FILE* file,EIF_REAL_EXTENDED* o);
void se_prinT6(FILE* file,EIF_BOOLEAN* o);
void se_prinT7(FILE* file,EIF_STRING* o);
void se_prinT8(FILE* file,EIF_POINTER* o);
void se_prinT10(FILE* file,EIF_INTEGER_16* o);
void se_prinT11(FILE* file,EIF_INTEGER_64* o);

/*
   This type is used to store a position in some Eiffel source file.
   It must be compatible with the implementation of class POSITION.
*/
typedef unsigned int se_position;

#define se_position2line(position) (((position) & 1) \
  ? ((EIF_INTEGER)(((position) >> 1) & 0x7FFF)) \
  : ((EIF_INTEGER)(((position) >> 8) & 0x1FFF)))

#define se_position2column(position) (((position) & 1) \
  ? 0 \
  : ((EIF_INTEGER)(((position) >> 1) & 0x7F)))

#define se_position2path_id(position) (((position) & 1) \
  ? ((position) >> 17) \
  : ((position) >> 21))

/*
  To be able to print a stack frame in a human readable format :
*/
typedef struct _se_frame_descriptor se_frame_descriptor;
struct _se_frame_descriptor {
  char* name; /* Eiffel name of the routine. */
  int use_current; /* Flag is 1 when this routine use Current. */
  int local_count; /* Number of C variables to print. */
  char* local_format; /* Format/type information. */
  int assertion_flag; /* 1 when assertions can be checked. */
};

/* For flat_check opion */
extern int assertion_depth;

/*
  To keep the track of execution in order to be able to print a
  dump when things goes wrong :
*/
typedef struct _se_dump_stack se_dump_stack;
struct _se_dump_stack {
  se_frame_descriptor* fd;
  void* current; /* NULL when not used. */
  se_position p; /* The current position. */
  se_dump_stack* caller; /* Back to the caller. */
  se_dump_stack* exception_origin; /* The exception origin if we are handling an exception. That object was malloc'ed */
  void*** locals;
};
extern se_dump_stack* se_dst;
int se_stack_size(se_dump_stack* ds);
void se_print_run_time_stack(void);
int se_print_one_frame(se_dump_stack*ds);
int se_print_one_frame_in(FILE* file, se_dump_stack*ds);

int se_rci(se_dump_stack*caller,void*C);
void error0(char*m,char*vv);
void error1(char*m,se_position position);
void error2(T0* o,se_position position);
T0* vc(T0* o, se_position position);
T0* se_string_inspect_check(T0* o, se_position position);
T0* ci(int id, T0* o, se_position position);
void ac_req(int v, char* vv);
void ac_ens(int v, char* vv);
void ac_inv(int v, char* vv);
void ac_liv(int v, char* vv);
void ac_insp(int v);
int ac_lvc(int lc,int lv1,int lv2);
void ac_civ(int v,char*vv);
T0* se_evobt(T0* o,se_position position);
void se_signal_handler(int sig);
void se_gc_check_id(void*o,int id);

/* The two following instructions are used by the exceptions system to keep
   the stack trace when jumping back to the retry clause */
se_dump_stack* se_new_dump_stack(se_dump_stack* copy);
void se_delete_dump_stack(se_dump_stack* ds);

#ifndef SE_TRACE
#    define set_dump_stack_top(ds) se_dst=(ds)
#else
#    define set_dump_stack_top(ds) \
       do { \
         se_print_call_trace(ds); \
         se_dst=(ds); \
       } while(0);
#endif
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*NATIVE_ARRAY[INTEGER_32]*/void r124set_all_with(se_dump_stack*caller,T124 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/T6 r124is_not_null(se_dump_stack*caller,T124 C);
/*NATIVE_ARRAY[INTEGER_32]*/T124 r124realloc(se_dump_stack*caller,T124 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/void r124copy_from(se_dump_stack*caller,T124 C,T124 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER_32]*/T6 r124all_default(se_dump_stack*caller,T124 C,T2 a1);
/*NATIVE_ARRAY[INTEGER_32]*/void r124clear_all(se_dump_stack*caller,T124 C,T2 a1);
/*ARRAY[INTEGER_32]*/void r123set_all_with(se_dump_stack*caller,T123* C,T2 a1);
/*ARRAY[INTEGER_32]*/void r123remove_last(se_dump_stack*caller,T123* C);
/*ARRAY[INTEGER_32]*/void r123add(se_dump_stack*caller,T123* C,T2 a1,T2 a2);
/*ARRAY[INTEGER_32]*/void r123add_last(se_dump_stack*caller,T123* C,T2 a1);
/*ARRAY[INTEGER_32]*/void r123ensure_capacity_and_bounds(se_dump_stack*caller,T123* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[INTEGER_32]*/void r123make(se_dump_stack*caller,T123* C,T2 a1,T2 a2);
/*ARRAY[INTEGER_32]*/T2 r123count(se_dump_stack*caller,T123* C);
/*ARRAY[INTEGER_32]*/T2 r123last(se_dump_stack*caller,T123* C);
/*ARRAY[INTEGER_32]*/T6 r123valid_index(se_dump_stack*caller,T123* C,T2 a1);
/*ARRAY[INTEGER_32]*/T6 r123is_empty(se_dump_stack*caller,T123* C);
/*ARRAY[INTEGER_32]*/T2 r123item(se_dump_stack*caller,T123* C,T2 a1);
/*ARRAY[INTEGER_32]*/void r123move(se_dump_stack*caller,T123* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[INTEGER_32]*/void r123put(se_dump_stack*caller,T123* C,T2 a1,T2 a2);
/*ARRAY[INTEGER_32]*/T6 r123all_default(se_dump_stack*caller,T123* C);
/*ARRAY[INTEGER_32]*/void r123clear_all(se_dump_stack*caller,T123* C);
extern se_frame_descriptor se_ifd123;
T123*se_i123(se_dump_stack*caller,T123*C);
/*STD_INPUT*/T3 r48last_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48unread_character(se_dump_stack*caller,T48* C);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_INPUT*/T0* r48std_output(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T3 r48filtered_last_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48filtered_read_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48filtered_unread_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48make(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T6 r48is_filtered(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48fill_buffer(se_dump_stack*caller,T48* C);
/*STD_INPUT*/void r48read_character(se_dump_stack*caller,T48* C);
/*STD_INPUT*/T6 r48can_unread_character(se_dump_stack*caller,T48* C);
/*STD_OUTPUT*/T0* r47std_output(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47se_atexit(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47make(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/T6 r47is_filtered(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47write_buffer(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47put_character(se_dump_stack*caller,T47* C,T3 a1);
/*STD_OUTPUT*/void r47flush(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/T6 r47can_put_character(se_dump_stack*caller,T47* C,T3 a1);
/*STD_OUTPUT*/void r47filtered_flush(se_dump_stack*caller,T47* C);
/*STD_OUTPUT*/void r47filtered_put_character(se_dump_stack*caller,T47* C,T3 a1);
/*INTEGER_16*/T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2);
/*INTEGER_16*/T2 r10hash_code(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T1 r10to_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/T6 r10fit_integer_8(se_dump_stack*caller,T10 C);
extern T0*oBC13io;
extern int fBC13io;
/*TOWER*/T0* r49io(se_dump_stack*caller,T49* C);
/*TOWER*/void r49empty(se_dump_stack*caller,T49* C,T2 a1);
/*TOWER*/void r49ajouter_disque(se_dump_stack*caller,T49* C,T2 a1);
/*TOWER*/T2 r49height(se_dump_stack*caller,T49* C);
/*TOWER*/T2 r49retirer_disque(se_dump_stack*caller,T49* C);
/*TOWER*/void r49afficher_etage(se_dump_stack*caller,T49* C,T2 a1);
/*TOWER*/void r49full(se_dump_stack*caller,T49* C,T2 a1);
/*STD_INPUT_OUTPUT*/void r40read_integer(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T3 r40last_character(se_dump_stack*caller,T40* C);
extern T0*oBC13std_input;
extern int fBC13std_input;
/*STD_INPUT_OUTPUT*/T0* r40std_input(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40unread_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T3 r40filtered_last_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T0* r40std_output(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_read_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_unread_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40input_is_filtered(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40output_is_filtered(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40make(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40is_connected(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40put_character(se_dump_stack*caller,T40* C,T3 a1);
/*STD_INPUT_OUTPUT*/void r40flush(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40put_string(se_dump_stack*caller,T40* C,T0* a1);
/*STD_INPUT_OUTPUT*/T6 r40can_put_character(se_dump_stack*caller,T40* C,T3 a1);
/*STD_INPUT_OUTPUT*/void r40read_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40can_unread_character(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/T6 r40end_of_input(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_flush(se_dump_stack*caller,T40* C);
/*STD_INPUT_OUTPUT*/void r40filtered_put_character(se_dump_stack*caller,T40* C,T3 a1);
extern se_frame_descriptor se_ifd40;
T40*se_i40(se_dump_stack*caller,T40*C);
/*BOOLEAN*/T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1);
/*BOOLEAN*/T6 r6_px_not(se_dump_stack*caller,T6 C);
/*BOOLEAN*/T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1);
/*INTEGER_8*/T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2);
/*INTEGER_8*/T2 r1hash_code(se_dump_stack*caller,T1 C);
/*INTEGER_32*/T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2is_default(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2default(se_dump_stack*caller);
/*INTEGER_32*/T6 r2in_range(se_dump_stack*caller,T2 C,T2 a1,T2 a2);
/*INTEGER_32*/T2 r2hash_code(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2abs(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T6 r2divisible(se_dump_stack*caller,T2 a1);
/*INTEGER_32*/T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_px_45(se_dump_stack*caller,T2 C);
/*HANOI*/T0* r25io(se_dump_stack*caller,T25* C);
/*HANOI*/void r25resolve(se_dump_stack*caller,T25* C,T2 a1,T0* a2,T0* a3,T0* a4);
/*HANOI*/void r25print_game(se_dump_stack*caller,T25* C);
/*HANOI*/void r25make(se_dump_stack*caller,T25* C);
/*CHARACTER*/T6 r3is_equal(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3is_default(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3default(se_dump_stack*caller);
/*CHARACTER*/T6 r3_ix_6261(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3_ix_60(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T6 r3in_range(se_dump_stack*caller,T3 C,T3 a1,T3 a2);
/*CHARACTER*/T6 r3_ix_6061(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T2 r3hash_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3is_digit(se_dump_stack*caller,T3 C);
/*CHARACTER*/T1 r3value(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3is_separator(se_dump_stack*caller,T3 C);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_not_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(se_dump_stack*caller,T9 C,T2 a1);
/*STRING*/T2 r7count(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7upper(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T3 r7item(se_dump_stack*caller,T7* C,T2 a1);
extern se_frame_descriptor se_ifd7;
T7*se_i7(se_dump_stack*caller,T7*C);
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env124;
typedef struct B123 gc123;
struct B123{T123 object;union {void*flag;gc123*next;} header;};
extern gc123*store123;
extern int store_left123;
extern fsoc*store_chunk123;
extern gc123*gc_free123;
typedef struct B48 gc48;
struct B48{T48 object;union {void*flag;gc48*next;} header;};
extern gc48*store48;
extern int store_left48;
extern fsoc*store_chunk48;
extern gc48*gc_free48;
typedef struct B47 gc47;
struct B47{T47 object;union {void*flag;gc47*next;} header;};
extern gc47*store47;
extern int store_left47;
extern fsoc*store_chunk47;
extern gc47*gc_free47;
typedef struct B49 gc49;
struct B49{T49 object;union {void*flag;gc49*next;} header;};
extern gc49*store49;
extern int store_left49;
extern fsoc*store_chunk49;
extern gc49*gc_free49;
typedef struct B40 gc40;
struct B40{T40 object;union {void*flag;gc40*next;} header;};
extern gc40*store40;
extern int store_left40;
extern fsoc*store_chunk40;
extern gc40*gc_free40;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
void gc_mark124(T124 o);
T124 new124(unsigned int size);
void gc_sweep123(fsoc*c);
void gc_mark123(T123*o);
void gc_align_mark123(fsoc*c,gc123*p);
extern fsoc H123;
T123*new123(void);
void gc_sweep48(fsoc*c);
void gc_mark48(T48*o);
void gc_align_mark48(fsoc*c,gc48*p);
extern fsoc H48;
T48*new48(void);
void gc_sweep47(fsoc*c);
void gc_mark47(T47*o);
void gc_align_mark47(fsoc*c,gc47*p);
extern fsoc H47;
T47*new47(void);
void gc_sweep49(fsoc*c);
void gc_mark49(T49*o);
void gc_align_mark49(fsoc*c,gc49*p);
extern fsoc H49;
T49*new49(void);
void gc_sweep40(fsoc*c);
void gc_mark40(T40*o);
void gc_align_mark40(fsoc*c,gc40*p);
extern fsoc H40;
T40*new40(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 125
extern T7*g[];
extern T7*t[];
extern char*p[];
extern void(*se_prinT[125])(FILE*,void*);
extern int se_strucT[];
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);

#ifdef __cplusplus
}
#endif
